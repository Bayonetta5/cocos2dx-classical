class CCParticleMeteor : public CCParticleSystemQuad {
	static CCParticleMeteor* create();
	static CCParticleMeteor* createWithTotalParticles(unsigned int numberOfParticles);
	bool init();
	~CCParticleMeteor();
	bool initWithTotalParticles(unsigned int numberOfParticles);
	CCParticleMeteor();
};
class CCSPXSprite : public CCAFCSprite {
	static CCSPXSprite* create(const char* spxPath, CCTexture2D* tex, int actionIndex);
	int getAnimationCount();
	CCAFCAnimation* getAnimationAt(int index, CCAFCClipMapping* mapping);
	CCAFCFileData* getFileData();
	int getImageCount();
	~CCSPXSprite();
};
class CCAFCFileData : public CCObject {
	string m_path;
	float m_resScale;
	~CCAFCFileData();
};
class CCMenuItemAtlasFont : public CCMenuItemLabel {
	static CCMenuItemAtlasFont* create(const char* value, const char* charMapFile, int itemWidth, int itemHeight, char startCharMap);
	~CCMenuItemAtlasFont();
	CCMenuItemAtlasFont();
};
class CCProgressFromTo : public CCActionInterval {
	static CCProgressFromTo* create(float duration, float fFromPercentage, float fToPercentage);
	void startWithTarget(CCNode* pTarget);
	void update(float time);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, float fFromPercentage, float fToPercentage);
	CCActionInterval* reverse();
};
class CCTMXObjectGroup : public CCObject {
	static CCTMXObjectGroup* create();
	int getObjectCount();
	CCTMXObject* getObjectAt(int index);
	CCDictionary& getProperties();
	string getProperty(const string& name);
	void addProperty(const string& key, const string& value);
	void setName(string var);
	void setOffsetX(float var);
	int getColor();
	string getName();
	void setOpacity(float var);
	~CCTMXObjectGroup();
	CCTMXObject* getObject(const string& name);
	const CCArray& getObjects();
	float getOffsetY();
	float getOffsetX();
	CCTMXObject* newObject();
	float getOpacity();
	void setOffsetY(float var);
	void setProperties(const CCDictionary& var);
	void setObjects(const CCArray& var);
	void setColor(int var);
};
class CCMoveBy : public CCActionInterval {
	static CCMoveBy* create(float duration, const CCPoint& deltaPosition, bool autoHeadOn, float initAngle);
	void startWithTarget(CCNode* pTarget);
	void update(float time);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCPoint& deltaPosition, bool autoHeadOn, float initAngle);
	CCActionInterval* reverse();
};
class CCTMXLayer : public CCNodeRGBA {
	static CCTMXLayer* create(int layerIndex, CCTMXMapInfo* mapInfo);
	const int* getGids();
	int getTileWidth();
	void setTileAt @ setTileAtiC(int gid, CCPoint loc);
	void setTileAt @ setTileAtiii(int gid, int x, int y);
	CCPoint getPositionAt @ getPositionAtC(CCPoint loc);
	CCPoint getPositionAt @ getPositionAtii(int x, int y);
	CCTMXMapInfo* getMapInfo();
	int getMinGid();
	float getVertexZ();
	CCTMXLayerInfo* getLayerInfo();
	void setTileWidth(int var);
	void setVertexZ(float var);
	int getMaxGid();
	void setAlphaFuncValue(float var);
	int getGidAt @ getGidAtC(CCPoint loc);
	int getGidAt @ getGidAtii(int x, int y);
	void setLayerWidth(int var);
	int getTileHeight();
	void removeTile(CCSprite* sprite);
	~CCTMXLayer();
	void setMapInfo(CCTMXMapInfo* var);
	CCSize getLayerSize();
	void setMinGid(int var);
	int getLayerHeight();
	void updateTileAt @ updateTileAtiC(int gid, CCPoint loc);
	void updateTileAt @ updateTileAtiii(int gid, int x, int y);
	void removeTileAt @ removeTileAtC(CCPoint loc);
	void removeTileAt @ removeTileAtii(int x, int y);
	void setUseAutomaticVertexZ(bool var);
	void setAntiAliasTexParameters();
	void setTileColorAt @ setTileColorAtcC(ccColor4B c, CCPoint loc);
	void setTileColorAt @ setTileColorAtcii(ccColor4B c, int x, int y);
	const int* copyGids();
	ccPosition getTileCoordinateAt(float x, float y);
	bool isUseAutomaticVertexZ();
	float getAlphaFuncValue();
	void markUseAutomaticVertexZ();
	void setLayerInfo(CCTMXLayerInfo* var);
	void setTileHeight(int var);
	string getProperty(const string& key);
	void setMaxGid(int var);
	CCSprite* tileAt @ tileAtC(CCPoint loc);
	CCSprite* tileAt @ tileAtii(int x, int y);
	void clearUseAutomaticVertexZ();
	void setLayerHeight(int var);
	int getLayerWidth();
};
class CCEaseCircleActionInOut : public CCActionEase {
	static CCEaseCircleActionInOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCTouchHandler : public CCObject {
	static CCTouchHandler* handlerWithDelegate(CCTouchDelegate* pDelegate, int nPriority);
	CCTouchDelegate* getDelegate();
	bool initWithDelegate(CCTouchDelegate* pDelegate, int nPriority);
	int getPriority();
	~CCTouchHandler();
	void setPriority(int nPriority);
	int getEnabledSelectors();
	void setDelegate(CCTouchDelegate* pDelegate);
	void setEnalbedSelectors(int nValue);
};
class TextField : public Widget {
	static TextField* create();
	static CCObject* createInstance();
	void setAnchorPoint(const CCPoint& pt);
	void setAttachWithIME(bool attach);
	int getFontSize();
	void onEnter();
	const char* getStringValue();
	void setPasswordStyleText(const char* styleText);
	string getDescription();
	CCNode* getVirtualRenderer();
	bool getDeleteBackward();
	const char* getPlaceHolder();
	bool getAttachWithIME();
	void setFontName(const string& name);
	bool getInsertText();
	void setInsertText(bool insertText);
	bool getDetachWithIME();
	~TextField();
	void setTextVerticalAlignment(CCVerticalTextAlignment alignment);
	const CCSize& getContentSize();
	void didNotSelectSelf();
	const char* getFontName();
	void setTextAreaSize(const CCSize& size);
	void attachWithIME();
	void setPasswordEnabled(bool enable);
	const char* getPasswordStyleText();
	void update(float dt);
	void setMaxLengthEnabled(bool enable);
	bool isPasswordEnabled();
	void setDeleteBackward(bool deleteBackward);
	void setFontSize(int size);
	void setPlaceHolder(const string& value);
	bool onTouchBegan(CCTouch* touch, CCEvent* unused_event);
	void setTextHorizontalAlignment(CCTextAlignment alignment);
	int getMaxLength();
	bool isMaxLengthEnabled();
	void setDetachWithIME(bool detach);
	void setText(const string& text);
	void setTouchAreaEnabled(bool enable);
	bool hitTest(const CCPoint& pt);
	void setMaxLength(int length);
	void setTouchSize(const CCSize& size);
	TextField();
	CCSize getTouchSize();
};
class CCProgressTo : public CCActionInterval {
	static CCProgressTo* create(float duration, float fPercent);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, float fPercent);
	void update(float time);
};
class CCMovementBoneData : public CCObject {
	float delay;
	float scale;
	float duration;
	string name;
	CCArray frameList;
	static CCMovementBoneData* create();
	bool init();
	~CCMovementBoneData();
	void addFrameData(CCFrameData* frameData);
	CCFrameData* getFrameData(int index);
	CCMovementBoneData();
};
class CCFlipX : public CCActionInstant {
	static CCFlipX* create(bool x);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithFlipX(bool x);
	void update(float time);
	~CCFlipX();
	CCFlipX();
	CCFiniteTimeAction* reverse();
};
class CCFlipY : public CCActionInstant {
	static CCFlipY* create(bool y);
	CCFiniteTimeAction* reverse();
	bool initWithFlipY(bool y);
	void update(float time);
	~CCFlipY();
	CCFlipY();
	CCObject* copyWithZone(CCZone* pZone);
};
class CCFileDownloader : public CCObject {
	static void purge();
	static CCFileDownloader* getInstance();
	void setFailedEntries(const CCArray& var);
	bool isDownloading();
	const CCArray& getDownloadEntries();
	const string& getFolder();
	void addFile @ addFilercsrcsb(const string& url, const string& dstFilename, bool append);
	void addFile @ addFilercsb(const string& url, bool append);
	void addFile @ addFilercsrcsulb(const string& url, const string& dstFilename, unsigned long sizeHint, bool append);
	void setDownloading(bool var);
	const CCArray& getFailedEntries();
	void markDownloading();
	string getCurrentDownloadingFileName();
	void start();
	void setDownloadEntries(const CCArray& var);
	void abort();
	void setFolder(const string& var);
	unsigned long getTotalSize();
	string getCurrentDownloadingFileFullPath();
	unsigned long getCurrentDownloadingFileSize();
	~CCFileDownloader();
	unsigned long getTotalDownloadedSize();
	void clearDownloading();
	unsigned long getCurrentDownloadedSize();
};
class ZOrderFrame : public Frame {
	static ZOrderFrame* create();
	int getZOrder();
	Frame* clone();
	void setZOrder(int zorder);
	void onEnter(Frame* nextFrame);
	ZOrderFrame();
};
class CCSAXParser {
	static void textHandler(void* ctx, const unsigned char* name, int len);
	static void endElement(void* ctx, const unsigned char* name);
	bool parse @ parsepcc(const char* pszFile);
	bool parse @ parsepccui(const char* pXMLData, unsigned int uDataLength);
	bool init(const char* pszEncoding);
	~CCSAXParser();
	void setDelegator(CCSAXDelegator* pDelegator);
	CCSAXParser();
};
class CCSPX3Sprite : public CCAFCSprite {
	int getAnimationCount();
	CCAFCAnimation* getAnimationAt(int index, CCAFCClipMapping* mapping);
	CCAFCFileData* getFileData();
	int getImageCount();
	~CCSPX3Sprite();
};
class ActionFrameEasing : public CCObject {
	float easeValue(float t);
	float bounceTime(float t);
	~ActionFrameEasing();
	ActionFrameEasing();
};
class CCDisplayData : public CCObject {
	DisplayType displayType;
	string displayName;
	static const char* changeDisplayToTexture(const char* displayName);
	static CCDisplayData* create();
	void copy(CCDisplayData* displayData);
	~CCDisplayData();
};
class CCShaderCache : public CCObject {
	static void purgeSharedShaderCache();
	static CCShaderCache* sharedShaderCache();
	void loadDefaultShaders();
	void addProgram(CCGLProgram* program, const char* key);
	~CCShaderCache();
	void reloadDefaultShaders();
	CCGLProgram* programForKey(const char* key);
	CCShaderCache();
};
class CCTreeFadeOut : public CCFadeOut {
	static CCTreeFadeOut* create(float d);
	void excludeNode(CCNode* n, bool recursively);
	void update(float time);
	CCActionInterval* reverse();
};
class CCControlUtils {
	static RGBA RGBfromHSV(HSV value);
	static CCRect CCRectUnion(const CCRect& src1, const CCRect& src2);
	static CCSprite* addSpriteToTargetWithPosAndAnchor(const char* spriteName, CCNode* target, CCPoint pos, CCPoint anchor);
	static HSV HSVfromRGB(RGBA value);
};
class ActionMoveFrame : public ActionFrame {
	void setPosition(CCPoint pos);
	~ActionMoveFrame();
	CCActionInterval* getAction(float fDuration);
	CCPoint getPosition();
	ActionMoveFrame();
};
class CCResourceLoaderListener {
	void onResourceLoadingDone();
	void onResourceLoadingProgress(float progress, float delta);
};
class CCTransitionFadeDown : public CCTransitionFadeTR {
	static CCTransitionFadeDown* create(float t, CCScene* scene);
	CCActionInterval* actionWithSize(const CCSize& size);
	~CCTransitionFadeDown();
};
class CCTransitionSplitCols : public CCTransitionScene, public CCTransitionEaseScene {
	static CCTransitionSplitCols* create(float t, CCScene* scene);
	CCActionInterval* action();
	CCActionInterval* easeActionWithAction(CCActionInterval* action);
	~CCTransitionSplitCols();
	void onEnter();
};
class CCEaseBackIn : public CCActionEase {
	static CCEaseBackIn* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCImagePickerCallback {
	void onImagePickingCancelled();
	void onImagePicked(const string& fullPath, int w, int h);
};
class CCTexture2D : public CCObject {
	bool m_bHasPremultipliedAlpha;
	bool m_bHasMipmaps;
	static void setDefaultAlphaPixelFormat(CCTexture2DPixelFormat format);
	static CCTexture2DPixelFormat defaultAlphaPixelFormat();
	static void PVRImagesHavePremultipliedAlpha(bool haveAlphaPremultiplied);
	CCGLProgram* getShaderProgram();
	bool initWithETCFile(const char* file);
	const char* stringForFormat();
	bool initWithImage(CCImage* uiImage);
	void setShaderProgram(CCGLProgram* var);
	float getMaxS();
	void releaseData(void* data);
	bool hasPremultipliedAlpha();
	unsigned int getPixelsHigh();
	void drawInRect(const CCRect& rect);
	void setTexParameters(ccTexParams* texParams);
	unsigned int bitsPerPixelForFormat @ bitsPerPixelForFormatC(CCTexture2DPixelFormat format);
	unsigned int bitsPerPixelForFormat @ bitsPerPixelForFormat();
	bool initWithData(const void* data, CCTexture2DPixelFormat pixelFormat, unsigned int pixelsWide, unsigned int pixelsHigh, const CCSize& contentSize);
	unsigned int getName();
	bool initWithString @ initWithStringpccpccf(const char* text, const char* fontName, float fontSize);
	bool initWithString @ initWithStringpccpccfrcCCC(const char* text, const char* fontName, float fontSize, const CCSize& dimensions, CCTextAlignment hAlignment, CCVerticalTextAlignment vAlignment);
	void setMaxT(float var);
	~CCTexture2D();
	int getRealLength();
	bool isNeedTime();
	CCSize getContentSize();
	float getMaxT();
	const CCPoint& getShadowStrokePadding();
	void setAliasTexParameters();
	void setAntiAliasTexParameters();
	void generateMipmap();
	const char* description();
	CCTexture2DPixelFormat getPixelFormat();
	void setNeedTime(bool var);
	void setRealLength(int var);
	void clearNeedTime();
	void* keepData(void* data, unsigned int length);
	const CCSize& getContentSizeInPixels();
	unsigned int getPixelsWide();
	void markNeedTime();
	void drawAtPoint(const CCPoint& point);
	bool hasMipmaps();
	bool initWithPVRFile(const char* file);
	void setMaxS(float var);
};
class CCPoolManager {
	static void purgePoolManager();
	static CCPoolManager* sharedPoolManager();
	void addObject(CCObject* pObject);
	void finalize();
	void pop();
	~CCPoolManager();
	CCPoolManager();
	void push();
	void removeObject(CCObject* pObject);
};
class CCParticleBatchNode : public CCNode, public CCTextureProtocol {
	static CCParticleBatchNode* create(const char* fileImage, unsigned int capacity);
	static CCParticleBatchNode* createWithTexture(CCTexture2D* tex, unsigned int capacity);
	void removeChildAtIndex(unsigned int index, bool doCleanup);
	void addChild @ addChildpCi(CCNode* child, int zOrder);
	void addChild @ addChildpC(CCNode* child);
	void addChild @ addChildpCii(CCNode* child, int zOrder, int tag);
	void draw();
	void setTexture(CCTexture2D* texture);
	bool initWithFile(const char* fileImage, unsigned int capacity);
	void disableParticle(unsigned int particleIndex);
	CCTexture2D* getTexture();
	void visit();
	void setBlendFunc(ccBlendFunc blendFunc);
	void removeAllChildrenWithCleanup(bool doCleanup);
	CCTextureAtlas* getTextureAtlas();
	~CCParticleBatchNode();
	void removeChild(CCNode* child, bool cleanup);
	ccBlendFunc getBlendFunc();
	void insertChild(CCParticleSystem* pSystem, unsigned int index);
	bool initWithTexture(CCTexture2D* tex, unsigned int capacity);
	void reorderChild(CCNode* child, int zOrder);
	void setTextureAtlas(CCTextureAtlas* var);
};
class CCTransitionScene : public CCScene {
	static CCTransitionScene* create(float t, CCScene* scene);
	void draw();
	void finish();
	void onEnter();
	void onExit();
	bool initWithDuration(float t, CCScene* scene);
	~CCTransitionScene();
	void cleanup();
	void hideOutShowIn();
};
class CCCallFuncND : public CCCallFuncN {
	long getClassTypeInfo();
	void execute();
	CCObject* copyWithZone(CCZone* pZone);
};
class CCPoint {
	float x;
	float y;
	static CCPoint forAngle(float a);
	CCPoint normalize();
	CCPoint project(const CCPoint& other);
	float getLengthSq();
	float getAngle @ getAnglercC(const CCPoint& other);
	float getAngle @ getAngle();
	CCPoint lerp(const CCPoint& other, float alpha);
	float getLength();
	void setPoint(float x, float y);
	bool equals(const CCPoint& target);
	CCPoint rotateByAngle(const CCPoint& pivot, float angle);
	float cross(const CCPoint& other);
	float getDistanceSq(const CCPoint& other);
	CCPoint getRPerp();
	CCPoint rotate(const CCPoint& other);
	bool fuzzyEquals(const CCPoint& target, float variance);
	float getDistance(const CCPoint& other);
	CCPoint(float x, float y);
	CCPoint();
	CCPoint(const CCPoint& other);
	CCPoint(const CCSize& size);
	CCPoint unrotate(const CCPoint& other);
	CCPoint getPerp();
	float dot(const CCPoint& other);
};
class NodeCreateCallFunc : public CCObject {
	~NodeCreateCallFunc();
};
class CCArray : public CCObject {
	static CCArray* createWithContentsOfFile(const char* pFileName);
	static CCArray* createWithArray(CCArray* otherArray);
	static CCArray* createWithCapacity(unsigned int capacity);
	static CCArray* createWithObject(CCObject* pObject);
	static CCArray* createWithContentsOfFileThreadSafe(const char* pFileName);
	static CCArray* create();
	bool initWithArray(CCArray* otherArray);
	void reverseObjects();
	void insertObject(CCObject* object, unsigned int index);
	void removeAllObjects();
	void exchangeObjectAtIndex(unsigned int index1, unsigned int index2);
	bool containsObject(CCObject* object);
	unsigned int capacity();
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithCapacity(unsigned int capacity);
	~CCArray();
	bool init();
	void removeObjectsInArray(CCArray* otherArray);
	void fastRemoveObjectAtIndex(unsigned int index);
	void addObject(CCObject* object);
	unsigned int indexOfObject(CCObject* object);
	void addObjectsFromArray(CCArray* otherArray);
	CCObject* lastObject();
	void exchangeObject(CCObject* object1, CCObject* object2);
	void fastRemoveObject(CCObject* object);
	void replaceObjectAtIndex(unsigned int uIndex, CCObject* pObject, bool bReleaseObject);
	CCObject* randomObject();
	void reduceMemoryFootprint();
	bool isEqualToArray(CCArray* pOtherArray);
	void acceptVisitor(CCDataVisitor& visitor);
	unsigned int count();
	bool initWithObject(CCObject* pObject);
	void removeObjectAtIndex(unsigned int index, bool bReleaseObj);
	void removeLastObject(bool bReleaseObj);
	void removeObject(CCObject* object, bool bReleaseObj);
	CCObject* objectAtIndex(unsigned int index);
};
class CCSpeed : public CCAction {
	static CCSpeed* create(CCActionInterval* pAction, float fSpeed);
	void startWithTarget(CCNode* pTarget);
	void setInnerAction(CCActionInterval* pAction);
	CCActionInterval* reverse();
	CCObject* copyWithZone(CCZone* pZone);
	void stop();
	void step(float dt);
	~CCSpeed();
	void setSpeed(float fSpeed);
	bool initWithAction(CCActionInterval* pAction, float fSpeed);
	CCActionInterval* getInnerAction();
	bool isDone();
	float getSpeed();
};
class CCSPX3TileSet : public CCObject {
	CCSPX3TileSetMode m_mode;
	int m_imageIndex;
	int m_tileWidth;
	int m_tileHeight;
	int m_tileColumns;
	int m_tileRows;
	int m_tileCount;
	static CCSPX3TileSet* create();
	~CCSPX3TileSet();
};
class CCShow : public CCActionInstant {
	static CCShow* create();
	CCFiniteTimeAction* reverse();
	CCObject* copyWithZone(CCZone* pZone);
	~CCShow();
	void update(float time);
};
class CCLayerClip : public CCLayerColor {
	static CCLayerClip* create @ creatercc(const ccColor4B& color);
	static CCLayerClip* create @ create();
	void markClipEnabled();
	bool isClipEnabled();
	void setClipRect(const CCRect& var);
	void clearClipEnabled();
	void visit();
	~CCLayerClip();
	const CCRect& getClipRect();
	void setPosition(const CCPoint& position);
	void setContentSize(const CCSize& contentSize);
	void setClipEnabled(bool var);
};
class CCFadeOut : public CCActionInterval {
	static CCFadeOut* create(float d);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCToggleVisibility : public CCActionInstant {
	static CCToggleVisibility* create();
	CCObject* copyWithZone(CCZone* pZone);
	~CCToggleVisibility();
	void update(float time);
};
class CCRepeatForever : public CCActionInterval {
	static CCRepeatForever* create(CCActionInterval* pAction);
	void startWithTarget(CCNode* pTarget);
	void setInnerAction(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void stop();
	void step(float dt);
	~CCRepeatForever();
	bool initWithAction(CCActionInterval* pAction);
	CCActionInterval* getInnerAction();
	bool isDone();
	CCActionInterval* reverse();
};
class CCSPXAction : public CCObject {
	CCSPXTransform m_transform;
	int m_frameCount;
	int m_maxFrameTile;
	~CCSPXAction();
};
class CCFadeOutBLTiles : public CCFadeOutTRTiles {
	static CCFadeOutBLTiles* create(float duration, const CCSize& gridSize);
	float testFunc(const CCSize& pos, float time);
};
class CCParticleSun : public CCParticleSystemQuad {
	static CCParticleSun* create();
	static CCParticleSun* createWithTotalParticles(unsigned int numberOfParticles);
	bool init();
	~CCParticleSun();
	bool initWithTotalParticles(unsigned int numberOfParticles);
};
class UICCLabelAtlas : public CCLabelAtlas {
	static UICCLabelAtlas* create();
	void setProperty @ setPropertyrcspCuiuiui(const string& s, CCTexture2D* texture, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);
	void setProperty @ setPropertyrcsrcsuiuiui(const string& s, const string& charMapFile, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);
	void updateDisplayedOpacity(unsigned char opacity);
	void draw();
	~UICCLabelAtlas();
};
class Label : public Widget {
	static Label* create();
	static CCObject* createInstance();
	int getStringLength();
	void setFontName(const string& name);
	void setTouchScaleChangeEnabled(bool enabled);
	int getFontSize();
	CCVerticalTextAlignment getTextVerticalAlignment();
	void setAnchorPoint(const CCPoint& pt);
	const char* getStringValue();
	void setText(const string& text);
	string getDescription();
	CCNode* getVirtualRenderer();
	CCTextAlignment getTextHorizontalAlignment();
	~Label();
	CCSize getTextAreaSize();
	void setTextVerticalAlignment(CCVerticalTextAlignment alignment);
	const CCSize& getContentSize();
	void setFontSize(int size);
	bool isTouchScaleChangeEnabled();
	void setTextHorizontalAlignment(CCTextAlignment alignment);
	const char* getFontName();
	void setTextAreaSize(const CCSize& size);
};
class CCKeypadHandler : public CCObject {
	static CCKeypadHandler* handlerWithDelegate(CCKeypadDelegate* pDelegate);
	CCKeypadDelegate* getDelegate();
	bool initWithDelegate(CCKeypadDelegate* pDelegate);
	void setDelegate(CCKeypadDelegate* pDelegate);
	~CCKeypadHandler();
};
class CCPacket : public CCObject {
	static CCPacket* createRawPacket(const char* buf, unsigned long len, int algorithm);
	static CCPacket* createStandardPacket @ createStandardPacketrcsipCi(const string& magic, int command, CCJSONObject* json, int algorithm);
	static CCPacket* createStandardPacket @ createStandardPacketpccul(const char* buf, unsigned long len);
	static CCPacket* createStandardPacket @ createStandardPacketrcsipCiii(const string& magic, int command, CCJSONObject* json, int protocolVersion, int serverVersion, int algorithm);
	bool getRaw();
	void setBuffer(char* var);
	Header& getHeader();
	unsigned long getPacketLength();
	~CCPacket();
	int getBodyLength();
	char* getBuffer();
	void setHeader(const Header& var);
	const char* getBody();
	typedef struct {
		int protocolVersion;
		int serverVersion;
		int command;
		int encryptAlgorithm;
		int length;
	} Header;
};
class CCArmatureDisplayData : public CCDisplayData {
	static CCArmatureDisplayData* create();
	~CCArmatureDisplayData();
};
class CCParticleRain : public CCParticleSystemQuad {
	static CCParticleRain* create();
	static CCParticleRain* createWithTotalParticles(unsigned int numberOfParticles);
	bool init();
	~CCParticleRain();
	bool initWithTotalParticles(unsigned int numberOfParticles);
};
class CCImagePicker {
	static void pickFromCamera(const string& path, CCImagePickerCallback* callback, int w, int h, bool keepRatio);
	static void pickFromFrontCamera(const string& path, CCImagePickerCallback* callback, int w, int h, bool keepRatio);
	static bool hasCamera();
	static void pickFromAlbum(const string& path, CCImagePickerCallback* callback, int w, int h, bool keepRatio);
	static bool hasFrontCamera();
};
class RichElementImage : public RichElement {
	static RichElementImage* create(int tag, const ccColor3B& color, unsigned char opacity, const char* filePath);
	bool init(int tag, const ccColor3B& color, unsigned char opacity, const char* filePath);
	~RichElementImage();
};
class CCSecureUserDefault {
	static void purge();
	static CCSecureUserDefault* getInstance();
	void setIntegerForKey(const char* pKey, int value);
	float getFloatForKey @ getFloatForKeypccf(const char* pKey, float defaultValue);
	float getFloatForKey @ getFloatForKeypcc(const char* pKey);
	bool getBoolForKey @ getBoolForKeypccb(const char* pKey, bool defaultValue);
	bool getBoolForKey @ getBoolForKeypcc(const char* pKey);
	void setDoubleForKey(const char* pKey, double value);
	void setFloatForKey(const char* pKey, float value);
	~CCSecureUserDefault();
	string getStringForKey @ getStringForKeypccrcs(const char* pKey, const string& defaultValue);
	string getStringForKey @ getStringForKeypcc(const char* pKey);
	void setStringForKey(const char* pKey, const string& value);
	void flush();
	int getIntegerForKey @ getIntegerForKeypcci(const char* pKey, int defaultValue);
	int getIntegerForKey @ getIntegerForKeypcc(const char* pKey);
	double getDoubleForKey @ getDoubleForKeypccd(const char* pKey, double defaultValue);
	double getDoubleForKey @ getDoubleForKeypcc(const char* pKey);
	void setBoolForKey(const char* pKey, bool value);
};
class CCSkewBy : public CCSkewTo {
	static CCSkewBy* create(float t, float deltaSkewX, float deltaSkewY);
	void startWithTarget(CCNode* pTarget);
	CCActionInterval* reverse();
	bool initWithDuration(float t, float sx, float sy);
};
class CCShaders {
	static void setColorMatrix(const kmMat4& mat4);
	static void setGray();
	static void setFlash(float r, float g, float b, float t);
	static void setShine(float width, CCPoint lb, CCPoint rt, ccColor4B color1, ccColor4B color2, ccColor4B color3, ccVertex3F gradientPositions, float time);
	static CCGLProgram* programForKey(const string& key);
	static void setBlur(CCSize nodeSize, CCSize blurSize, ccColor4F blurSubtract);
	static void setLighting(ccColor4B mul, ccColor3B add);
};
class CCParticleFireworks : public CCParticleSystemQuad {
	static CCParticleFireworks* create();
	static CCParticleFireworks* createWithTotalParticles(unsigned int numberOfParticles);
	bool init();
	~CCParticleFireworks();
	bool initWithTotalParticles(unsigned int numberOfParticles);
};
class CCAssetInputStream : public CCObject {
	static CCAssetInputStream* create(const string& path);
	unsigned long available();
	int readShort(short* ret);
	int read(char* buffer, unsigned long length);
	unsigned long getLength();
	unsigned long seek(int offset, int mode);
	int readInt64(long long* ret);
	~CCAssetInputStream();
	int readInt(int* ret);
	int readByte(char* ret);
	void setBigEndian(bool big);
	bool isBigEndian();
	void close();
	char* getBuffer();
	bool open();
	unsigned long getPosition();
};
class CCDatabase : public CCObject {
	static CCDatabase* create(string path);
	static bool isThreadSafe();
	static string sqliteLibVersion();
	CCResultSet* getTableSchema(string tableName);
	void setBusyRetryTimeout(int var);
	void clearInUse();
	CCResultSet* getSchema();
	bool databaseOpened();
	bool close();
	~CCDatabase();
	bool open(int flags);
	void setVersion(int v);
	const string& getDatabasePath();
	bool hadError();
	bool executeSQL(const void* data, unsigned long length);
	void setInUse(bool var);
	void markInUse();
	void setShouldCacheStatements(bool value);
	int getBusyRetryTimeout();
	bool shouldCacheStatements();
	bool rollback();
	int lastErrorCode();
	bool columnExists(string tableName, string columnName);
	long long lastInsertRowId();
	bool beginTransaction();
	string lastErrorMessage();
	int getVersion();
	bool isInTransaction();
	bool goodConnection();
	bool tableExists(string tableName);
	void clearCachedStatements();
	bool commit();
	bool beginDeferredTransaction();
	int changes();
	bool isInUse();
};
class CCPrettyPrinter : public CCDataVisitor {
	void clear();
	void visitObject(const CCObject* p);
	void visit @ visitpcC(const CCInteger* p);
	void visit @ visitpcC(const CCBool* p);
	void visit @ visitpcC(const CCFloat* p);
	void visit @ visitpcC(const CCDouble* p);
	void visit @ visitpcC(const CCString* p);
	void visit @ visitpcC(const CCArray* p);
	void visit @ visitpcC(const CCDictionary* p);
	void visit @ visitpcC(const CCSet* p);
	string getResult();
};
class CCGridAction : public CCActionInterval {
	static CCGridAction* create(float duration, const CCSize& gridSize);
	void startWithTarget(CCNode* pTarget);
	CCGridBase* getGrid();
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCSize& gridSize);
	CCActionInterval* reverse();
};
class CCPlace : public CCActionInstant {
	static CCPlace* create(const CCPoint& pos);
	CCObject* copyWithZone(CCZone* pZone);
	~CCPlace();
	bool initWithPosition(const CCPoint& pos);
	void update(float time);
};
class CCColliderDetector : public CCObject {
	static CCColliderDetector* create @ createpC(CCBone* bone);
	static CCColliderDetector* create @ create();
	CCBone* getBone();
	void addContourData(CCContourData* contourData);
	void addContourDataList(CCArray* contourDataList);
	bool getActive();
	void setActive(bool active);
	void updateTransform(CCAffineTransform& t);
	~CCColliderDetector();
	void removeAll();
	bool init @ initpC(CCBone* bone);
	bool init @ init();
	void removeContourData(CCContourData* contourData);
	void setBone(CCBone* var);
	CCArray* getColliderBodyList();
};
class CCMenuItem : public CCNodeRGBA {
	static CCMenuItem* create();
	void setEnabled(bool value);
	void activate();
	void unregisterScriptTapHandler();
	bool isEnabled();
	void selected();
	~CCMenuItem();
	bool isSelected();
	int getScriptTapHandler();
	void registerScriptTapHandler(int nHandler);
	void unselected();
	CCRect rect();
};
class CCSAXDelegator {
	void textHandler(void* ctx, const char* s, int len);
	void endElement(void* ctx, const char* name);
};
class Margin {
	float left;
	float top;
	float right;
	float bottom;
	void setMargin(float l, float t, float r, float b);
	bool equals(const Margin& target);
	Margin(float l, float t, float r, float b);
	Margin();
	Margin(const Margin& other);
};
class CCMenu : public CCLayerRGBA {
	static CCMenu* create();
	static CCMenu* createWithArray(CCArray* pArrayOfItems);
	static CCMenu* createWithItem(CCMenuItem* item);
	bool initWithArray(CCArray* pArrayOfItems);
	void addChild @ addChildpCi(CCNode* child, int zOrder);
	void addChild @ addChildpC(CCNode* child);
	void addChild @ addChildpCii(CCNode* child, int zOrder, int tag);
	void alignItemsVertically();
	bool ccTouchBegan(CCTouch* touch, CCEvent* event);
	void ccTouchEnded(CCTouch* touch, CCEvent* event);
	bool isOpacityModifyRGB();
	bool isEnabled();
	void setOpacityModifyRGB(bool bValue);
	void setHandlerPriority(int newPriority);
	~CCMenu();
	bool init();
	void alignItemsHorizontallyWithPadding(float padding);
	void alignItemsInColumnsWithArray(CCArray* rows);
	void alignItemsHorizontally();
	void setEnabled(bool value);
	void alignItemsInRowsWithArray(CCArray* columns);
	void ccTouchMoved(CCTouch* touch, CCEvent* event);
	void onExit();
	void ccTouchCancelled(CCTouch* touch, CCEvent* event);
	void removeChild(CCNode* child, bool cleanup);
	void alignItemsVerticallyWithPadding(float padding);
	void registerWithTouchDispatcher();
};
class CCResultSet : public CCObject {
	int columnCount();
	bool boolForColumn(string columnName);
	long long int64ForColumnIndex(int columnIdx);
	long longForColumn(string columnName);
	string stringForColumn(string columnName);
	~CCResultSet();
	CCDatabase* getDatabase();
	string stringForColumnIndex(int columnIdx);
	bool hasAnotherRow();
	const void* dataNoCopyForColumn(string columnName, unsigned long* outLen);
	int intForColumn(string columnName);
	bool next();
	long long int64ForColumn(string columnName);
	CCStatement* getStatement();
	string columnNameForIndex(int columnIdx);
	double doubleForColumnIndex(int columnIdx);
	const void* dataForColumnIndex(int columnIdx, unsigned long* outLen);
	long longForColumnIndex(int columnIdx);
	int columnIndexForName(string columnName);
	bool columnIsNull(string columnName);
	const void* dataForColumn(string columnName, unsigned long* outLen);
	int intForColumnIndex(int columnIdx);
	bool columnIndexIsNull(int columnIdx);
	bool boolForColumnIndex(int columnIdx);
	double doubleForColumn(string columnName);
	const void* dataNoCopyForColumnIndex(int columnIdx, unsigned long* outLen);
};
class CCAccelerometer {
	~CCAccelerometer();
	void setAccelerometerInterval(float interval);
	void setDelegate(CCAccelerometerDelegate* pDelegate);
	CCAccelerometer();
};
class CCFadeOutUpTiles : public CCFadeOutTRTiles {
	static CCFadeOutUpTiles* create(float duration, const CCSize& gridSize);
	void transformTile(const CCPoint& pos, float distance);
	float testFunc(const CCSize& pos, float time);
};
class CCTransitionProgressInOut : public CCTransitionProgress {
	static CCTransitionProgressInOut* create(float t, CCScene* scene);
};
class CCOrbitCamera : public CCActionCamera {
	static CCOrbitCamera* create(float t, float radius, float deltaRadius, float angleZ, float deltaAngleZ, float angleX, float deltaAngleX);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float t, float radius, float deltaRadius, float angleZ, float deltaAngleZ, float angleX, float deltaAngleX);
	void sphericalRadius(float* r, float* zenith, float* azimuth);
	void update(float time);
	~CCOrbitCamera();
};
class CCAnimationFrame : public CCObject {
	void setSpriteFrame(CCSpriteFrame* var);
	CCDictionary* getUserInfo();
	void setDelayUnits(float var);
	CCObject* copyWithZone(CCZone* pZone);
	CCSpriteFrame* getSpriteFrame();
	~CCAnimationFrame();
	void setUserInfo(CCDictionary* var);
	float getDelayUnits();
	bool initWithSpriteFrame(CCSpriteFrame* spriteFrame, float delayUnits, CCDictionary* userInfo);
};
class TextureFrame : public Frame {
	static TextureFrame* create();
	string getTextureName();
	void setNode(CCNode* node);
	void onEnter(Frame* nextFrame);
	Frame* clone();
	void setTextureName(string textureName);
};
class CCParallaxNode : public CCNode {
	static CCParallaxNode* create();
	void addChild @ addChildpCuii(CCNode* child, unsigned int zOrder, int tag);
	void addChild @ addChildpCuircCrcC(CCNode* child, unsigned int z, const CCPoint& parallaxRatio, const CCPoint& positionOffset);
	void visit();
	void removeAllChildrenWithCleanup(bool cleanup);
	~CCParallaxNode();
	void removeChild(CCNode* child, bool cleanup);
	_ccArray* getParallaxArray();
	void setParallaxArray(_ccArray* var);
};
class CCDirector : public CCObject, public TypeInfo {
	static CCDirector* sharedDirector();
	void pause();
	void setDelegate(CCDirectorDelegate* pDelegate);
	void setContentScaleFactor(float scaleFactor);
	void setAlphaBlending(bool bOn);
	CCSize getWinSizeInPixels();
	float getDeltaTime();
	void setGLDefaultValues();
	float getContentScaleFactor();
	CCPoint convertToUI(const CCPoint& obPoint);
	void popToRootScene();
	CCKeypadDispatcher* getKeypadDispatcher();
	CCNode* getNotificationNode();
	CCSize getWinSize();
	void end();
	bool isSendCleanupToScene();
	CCPoint getVisibleOrigin();
	void mainLoop();
	void setDepthTest(bool bOn);
	float getSecondsPerFrame();
	~CCDirector();
	void setAccelerometer(CCAccelerometer* var);
	void setDefaultValues();
	bool init();
	void setScheduler(CCScheduler* var);
	void reshapeProjection(const CCSize& newWindowSize);
	void startAnimation();
	CCEGLView* getOpenGLView();
	CCScene* getRunningScene();
	void setViewport();
	void stopAnimation();
	void setKeypadDispatcher(CCKeypadDispatcher* var);
	void popToSceneStackLevel(int level);
	ccDirectorProjection getProjection();
	void resume();
	void setTouchDispatcher(CCTouchDispatcher* var);
	bool isNextDeltaTimeZero();
	CCDirectorDelegate* getDelegate();
	void setActionManager(CCActionManager* var);
	void setOpenGLView(CCEGLView* pobOpenGLView);
	CCPoint convertToGL(const CCPoint& obPoint);
	void purgeCachedData();
	unsigned int getTotalFrames();
	void runWithScene(CCScene* pScene);
	void setNotificationNode(CCNode* node);
	void drawScene();
	void popScene();
	bool isDisplayStats();
	void setProjection(ccDirectorProjection kProjection);
	CCTouchDispatcher* getTouchDispatcher();
	float getZEye();
	void setNextDeltaTimeZero(bool bNextDeltaTimeZero);
	CCAccelerometer* getAccelerometer();
	CCSize getVisibleSize();
	CCScheduler* getScheduler();
	void pushScene(CCScene* pScene);
	long getClassTypeInfo();
	double getAnimationInterval();
	bool isPaused();
	void setDisplayStats(bool bDisplayStats);
	void replaceScene(CCScene* pScene);
	void setAnimationInterval(double dValue);
	CCActionManager* getActionManager();
};
class CCRepeat : public CCActionInterval {
	static CCRepeat* create(CCFiniteTimeAction* pAction, unsigned int times);
	void startWithTarget(CCNode* pTarget);
	void setInnerAction(CCFiniteTimeAction* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void stop();
	void update(float dt);
	~CCRepeat();
	bool initWithAction(CCFiniteTimeAction* pAction, unsigned int times);
	CCFiniteTimeAction* getInnerAction();
	bool isDone();
	CCActionInterval* reverse();
};
class ScaleFrame : public Frame {
	static ScaleFrame* create();
	void setScaleY(float scaleY);
	void setScaleX(float scaleX);
	void onEnter(Frame* nextFrame);
	float getScaleY();
	float getScaleX();
	Frame* clone();
	void setScale(float scale);
	void apply(float percent);
};
class CCMenuItemSprite : public CCMenuItem {
	static CCMenuItemSprite* create(CCNode* normalSprite, CCNode* selectedSprite, CCNode* disabledSprite);
	void setFocus(bool flag);
	void setEnabled(bool bEnabled);
	void setFocusIsAttachment(bool var);
	void centerAlignImages();
	void setNormalImage(CCNode* var);
	void setDisabledImage(CCNode* var);
	void clearFocusIsAttachment();
	void setSelectedImage(CCNode* var);
	CCNode* getDisabledImage();
	bool isFocus();
	CCNode* getSelectedImage();
	void markFocusIsAttachment();
	CCNode* getNormalImage();
	bool isFocusIsAttachment();
	void selected();
	CCNode* getFocusImage();
	void unselected();
	void setFocusImage(CCNode* focusImage);
};
class PageViewDataSource {
	void pageItemDidRecycled(PageView* pv, Widget* item);
	Widget* pageItemAtIndex(PageView* pv, int index);
	int pageViewItemCount(PageView* pv);
};
class ColliderBody : public CCObject {
	CCContourData* getContourData();
	~ColliderBody();
};
class CCSortableObject {
	unsigned int getObjectID();
	void setObjectID(unsigned int objectID);
	~CCSortableObject();
};
class CCIMEDispatcher {
	static CCIMEDispatcher* sharedDispatcher();
	const char* getContentText();
	void dispatchDeleteBackward();
	void dispatchInsertText(const char* pText, int nLen);
	void dispatchKeyboardWillShow(CCIMEKeyboardNotificationInfo& info);
	~CCIMEDispatcher();
	void dispatchKeyboardDidShow(CCIMEKeyboardNotificationInfo& info);
	void dispatchKeyboardWillHide(CCIMEKeyboardNotificationInfo& info);
	void dispatchKeyboardDidHide(CCIMEKeyboardNotificationInfo& info);
};
class CCZone {
	CCZone(CCObject* pObject);
};
class CCLabelProtocol {
	void setString(const char* label);
	const char* getString();
};
class CCInteger : public CCObject {
	static CCInteger* create(int v);
	int getValue();
	void acceptVisitor(CCDataVisitor& visitor);
};
class ActionManager : public CCObject {
	static void purge();
	static ActionManager* shareManager();
	ActionObject* getActionByName(const char* jsonName, const char* actionName);
	~ActionManager();
	ActionObject* playActionByName @ playActionByNamepccpccpC(const char* jsonName, const char* actionName, CCCallFunc* func);
	ActionObject* playActionByName @ playActionByNamepccpcc(const char* jsonName, const char* actionName);
	void releaseActions();
};
class CCActionInstant : public CCFiniteTimeAction {
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	~CCActionInstant();
	void step(float dt);
	bool isDone();
	CCFiniteTimeAction* reverse();
};
class CCEaseSineIn : public CCActionEase {
	static CCEaseSineIn* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCComAudio : public CCComponent {
	static CCComAudio* create();
	static CCObject* createInstance();
	void stopAllEffects();
	void onEnter();
	bool serialize(void* r);
	float getEffectsVolume();
	void stopEffect(unsigned int nSoundId);
	float getBackgroundMusicVolume();
	bool willPlayBackgroundMusic();
	void pauseBackgroundMusic();
	void setBackgroundMusicVolume(float volume);
	void end();
	bool isEnabled();
	void stopBackgroundMusic @ stopBackgroundMusic();
	void stopBackgroundMusic @ stopBackgroundMusicb(bool bReleaseData);
	~CCComAudio();
	bool isBackgroundMusicPlaying();
	bool init();
	bool isLoop();
	void pauseAllEffects();
	void setEnabled(bool b);
	void preloadBackgroundMusic(const char* pszFilePath);
	void playBackgroundMusic @ playBackgroundMusicpcc(const char* pszFilePath);
	void playBackgroundMusic @ playBackgroundMusicpccb(const char* pszFilePath, bool bLoop);
	void playBackgroundMusic @ playBackgroundMusic();
	unsigned int playEffect @ playEffectpcc(const char* pszFilePath);
	unsigned int playEffect @ playEffectpccb(const char* pszFilePath, bool bLoop);
	unsigned int playEffect @ playEffect();
	void resumeAllEffects();
	void setLoop(bool bLoop);
	void unloadEffect(const char* pszFilePath);
	void rewindBackgroundMusic();
	void onExit();
	void preloadEffect(const char* pszFilePath);
	void pauseEffect(unsigned int nSoundId);
	void resumeBackgroundMusic();
	void setFile(const char* pszFilePath);
	void setEffectsVolume(float volume);
	const char* getFile();
	void resumeEffect(unsigned int nSoundId);
};
class LayoutParameter : public CCObject {
	static LayoutParameter* create();
	LayoutParameter* clone();
	LayoutParameterType getLayoutType();
	const Margin& getMargin();
	LayoutParameter* createCloneInstance();
	void copyProperties(LayoutParameter* model);
	void setMargin(const Margin& margin);
	~LayoutParameter();
};
class CCToast : public CCLayer {
	static CCToast* create(CCNode* owner, CCNode* content, int tag, float duration, CCFiniteTimeAction* inAction, CCFiniteTimeAction* outAction);
	static void forceRemove(CCNode* owner, int tag);
	~CCToast();
};
class CCShaky3D : public CCGrid3DAction {
	static CCShaky3D* create(float duration, const CCSize& gridSize, int range, bool shakeZ);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCSize& gridSize, int range, bool shakeZ);
	void update(float time);
};
class CCBlendProtocol {
	ccBlendFunc getBlendFunc();
	void setBlendFunc(ccBlendFunc blendFunc);
};
class CCAFCSprite : public CCNodeRGBA, public CCBlendProtocol {
	static CCSpriteBatchNode* createBatchNode(CCTexture2D* tex);
	void addChild(CCNode* child, int z, int tag);
	float getUnitInterval();
	void setUnitInterval(float interval);
	void setDebugDrawFrameRect(bool flag);
	int getLoopCount();
	void setLoopCount(int loop);
	CCRect getCollisionRect(int index);
	int getAnimationCount();
	CCAFCAnimation* getAnimationAt(int index, CCAFCClipMapping* mapping);
	void setFrameIndex(int index);
	int getCurrentFrame();
	void setForceTickMode(bool flag);
	int getCollisionRectCount();
	bool isForceTickMode();
	bool isFlipX();
	bool isFlipY();
	~CCAFCSprite();
	void addClipMapping(CCAFCClipMapping* mapping);
	void draw();
	ccBlendFunc getBlendFunc();
	CCAFCFileData* getFileData();
	CCRect getFrameRectRelativeToParent();
	void setReverse(bool flag);
	void setFlipY(bool flipY);
	void setFlipX(bool flipX);
	CCPoint getFrameOffset();
	int getFrameCount();
	void playAnimation @ playAnimationii(int index, int mappingTag);
	void playAnimation @ playAnimationipC(int index, CCAFCClipMapping* mapping);
	bool isReverse();
	int getCurrentAnimationIndex();
	CCAFCClipMapping* getClipMappingByTag(int tag);
	CCRect getCollisionRectRelativeToWorld(int index);
	void tick(float delta);
	void setAFCSpriteCallback(CCAFCSpriteCallback* callback);
	CCRect getFrameRect();
	CCRect getFrameRectRelativeToWorld();
	void setIgnoreFrameOffset(bool flag);
	void setColor(const ccColor3B& color);
	bool isAnimationEnded();
	void setBlendFunc(ccBlendFunc blendFunc);
	bool isIgnoreFrameOffset();
	CCRect getCollisionRectRelativeToParent(int index);
	void setDebugDrawCollisionRect(bool flag);
	bool isPaused();
	void removeClipMappingByTag(int tag);
	CCAFCAnimation* getCurrentAnimationData();
	int getImageCount();
	void setPaused(bool flag);
};
class CCTransitionSlideInT : public CCTransitionSlideInL {
	static CCTransitionSlideInT* create(float t, CCScene* scene);
	CCActionInterval* action();
	~CCTransitionSlideInT();
	void initScenes();
};
class Frame : public CCObject {
	Frame* clone();
	void setNode(CCNode* node);
	void onEnter(Frame* nextFrame);
	void setTimeline(Timeline* timeline);
	~Frame();
	unsigned int getFrameIndex();
	void apply(float percent);
	bool isTween();
	void setFrameIndex(unsigned int frameIndex);
	void setTween(bool tween);
	Timeline* getTimeline();
	CCNode* getNode();
};
class CCTransitionSlideInR : public CCTransitionSlideInL {
	static CCTransitionSlideInR* create(float t, CCScene* scene);
	CCActionInterval* action();
	~CCTransitionSlideInR();
	void initScenes();
};
class CCTransitionSlideInL : public CCTransitionScene, public CCTransitionEaseScene {
	static CCTransitionSlideInL* create(float t, CCScene* scene);
	void onEnter();
	~CCTransitionSlideInL();
	CCActionInterval* action();
	CCActionInterval* easeActionWithAction(CCActionInterval* action);
	void initScenes();
};
class CCTouchDelegate {
	bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	void ccTouchesCancelled(CCSet* pTouches, CCEvent* pEvent);
	~CCTouchDelegate();
	void ccTouchCancelled(CCTouch* pTouch, CCEvent* pEvent);
	void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	void ccTouchesBegan(CCSet* pTouches, CCEvent* pEvent);
	void ccTouchesMoved(CCSet* pTouches, CCEvent* pEvent);
	CCTouchDelegate();
	void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	void ccTouchesEnded(CCSet* pTouches, CCEvent* pEvent);
};
class CCProcessBase : public CCObject {
	int getRawDuration();
	void setCurrentPercent(float var);
	bool getIsPause();
	void pause();
	int getCurrentFrameIndex();
	~CCProcessBase();
	CCTweenType getTweenEasing();
	void play(int durationTo, int durationTween, int loop, int tweenEasing);
	float getCurrentPercent();
	void resume();
	void setIsComplete(bool var);
	void setTweenEasing(CCTweenType var);
	void stop();
	void update(float dt);
	void setLoopType(AnimationType var);
	bool getIsComplete();
	float getProcessScale();
	void setRawDuration(int var);
	AnimationType getLoopType();
	void setIsPause(bool var);
	bool getIsPlaying();
	void setProcessScale(float var);
	void setIsPlaying(bool var);
};
class ActionNode : public CCObject {
	void addFrame(ActionFrame* frame);
	void setObject(CCObject* node);
	void setUnitTime(float fTime);
	bool updateActionToTimeLine(float fTime);
	void insertFrame(int index, ActionFrame* frame);
	void setActionTag(int tag);
	void deleteFrame(ActionFrame* frame);
	~ActionNode();
	CCObject* getObject();
	int getFirstFrameIndex();
	bool isActionDoneOnce();
	int getActionTag();
	int getLastFrameIndex();
	float getUnitTime();
	void stopAction();
	void playAction();
	void clearAllFrame();
};
class CCMWLoader {
	static CCMWFileData* load(const char* path);
};
class CCTransitionSlideInB : public CCTransitionSlideInL {
	static CCTransitionSlideInB* create(float t, CCScene* scene);
	CCActionInterval* action();
	~CCTransitionSlideInB();
	void initScenes();
};
class CCAssetOutputStream : public CCObject {
	static CCAssetOutputStream* create(const string& path, bool append);
	bool open();
	const string& getPath();
	~CCAssetOutputStream();
	int write @ writepciul(const int* data, unsigned long len);
	int write @ writepccul(const char* data, unsigned long len);
	void close();
	unsigned long seek(int offset, int mode);
	unsigned long getPosition();
};
class CCComponent : public CCObject {
	static CCComponent* create();
	void setEnabled(bool b);
	void onEnter();
	void onExit();
	void setName(const char* pName);
	bool isEnabled();
	bool serialize(void* r);
	void update(float delta);
	~CCComponent();
	CCNode* getOwner();
	bool init();
	void setOwner(CCNode* pOwner);
	const char* getName();
};
class CCLocalization : public CCObject {
	static CCLocalization* sharedLocalization();
	void addAndroidStrings(const string& lan, const string& path, bool merge);
	string getString(const string& key);
	~CCLocalization();
};
class CCGrabber : public CCObject {
	void beforeRender(CCTexture2D* pTexture);
	void grab(CCTexture2D* pTexture);
	~CCGrabber();
	void afterRender(CCTexture2D* pTexture);
};
class CCTransitionSplitRows : public CCTransitionSplitCols {
	static CCTransitionSplitRows* create(float t, CCScene* scene);
	CCActionInterval* action();
	~CCTransitionSplitRows();
};
class CCFlipY3D : public CCFlipX3D {
	static CCFlipY3D* create(float duration);
	void update(float time);
	CCObject* copyWithZone(CCZone* pZone);
};
class CCAFCAnimation : public CCObject {
	static CCAFCAnimation* create();
	void addFrame(CCAFCFrame* f);
	int getFrameCount();
	CCAFCFrame* getFrameAt(int index);
	~CCAFCAnimation();
};
class CCEaseBackInOut : public CCActionEase {
	static CCEaseBackInOut* create(CCActionInterval* pAction);
	CCActionInterval* reverse();
	void update(float time);
	CCObject* copyWithZone(CCZone* pZone);
};
class CCLocale : public CCObject {
	static CCLocale* sharedLocale();
	string getCountry();
	string getLanguage();
	string getISOLanguage();
	~CCLocale();
};
class CCJSONParser {
	static CCObject* load @ loadrcs(const string& path);
	static CCObject* load @ loadpccul(const char* json, unsigned long length);
};
class UIScrollInterface {
	~UIScrollInterface();
};
class CCProfilingTimer : public CCObject {
	string m_NameStr;
	int numberOfCalls;
	int m_dAverageTime1;
	int m_dAverageTime2;
	long long totalTime;
	int minTime;
	int maxTime;
	cc_timeval m_sStartTime;
	void reset();
	const char* description();
	~CCProfilingTimer();
	bool initWithName(const char* timerName);
	cc_timeval* getStartTime();
};
class CCEaseCircleActionOut : public CCActionEase {
	static CCEaseCircleActionOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCArcticLoader {
	static CCArcticFileData* load(const char* asPath);
};
class CCTransitionSceneOriented : public CCTransitionScene {
	static CCTransitionSceneOriented* create(float t, CCScene* scene, tOrientation orientation);
	~CCTransitionSceneOriented();
	bool initWithDuration(float t, CCScene* scene, tOrientation orientation);
};
class CCScroller : public CCObject {
	static CCScroller* create();
	float getCurrX();
	float getCurrY();
	void fling(float startX, float startY, float velocityX, float velocityY, float minX, float maxX, float minY, float maxY);
	bool isFinished();
	void setScrollFriction(float friction);
	float getCurrVelocity();
	void startScroll @ startScrollffffi(float startX, float startY, float dx, float dy, int duration);
	void startScroll @ startScrollffff(float startX, float startY, float dx, float dy);
	~CCScroller();
	float getStartY();
	float getStartX();
	void forceFinished(bool finished);
	float getFinalY();
	float getFinalX();
	int getDuration();
	void setFinalY(float newY);
	void setFinalX(float newX);
	int timePassed();
	bool computeScrollOffset();
	void abortAnimation();
	void extendDuration(int extend);
};
class CCTintBy : public CCActionInterval {
	static CCTintBy* create(float duration, short deltaRed, short deltaGreen, short deltaBlue);
	void startWithTarget(CCNode* pTarget);
	CCActionInterval* reverse();
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, short deltaRed, short deltaGreen, short deltaBlue);
	void update(float time);
};
class CCSPX3Manager : public CCObject {
	static CCSPX3Manager* getInstance();
	CCSPX3FileData* load(const char* spxPath);
	void releaseAllAnimationFileData();
	CCAFCAnimation* getAnimationData(CCSPX3FileData* spx, int animIndex, CCAFCClipMapping* mapping);
	~CCSPX3Manager();
};
class CCWaves3D : public CCGrid3DAction {
	static CCWaves3D* create(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);
	void update(float time);
	float getAmplitudeRate();
	void setAmplitude(float fAmplitude);
	float getAmplitude();
	void setAmplitudeRate(float fAmplitudeRate);
};
class RichElement : public CCObject {
	bool init(int tag, const ccColor3B& color, unsigned char opacity);
	~RichElement();
};
class CCLayer : public CCNode, public CCTouchDelegate, public CCAccelerometerDelegate, public CCKeypadDelegate {
	static CCLayer* create();
	void unregisterScriptTouchHandler();
	void onEnter();
	void keyBackClicked();
	bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	void setAccelerometerInterval(double interval);
	void ccTouchesCancelled(CCSet* pTouches, CCEvent* pEvent);
	void didAccelerate(CCAcceleration* pAccelerationValue);
	void unregisterScriptAccelerateHandler();
	void ccTouchesMoved(CCSet* pTouches, CCEvent* pEvent);
	void registerScriptAccelerateHandler(int nHandler);
	int getTouchMode();
	void setAccelerometerEnabled(bool value);
	bool isSwallowTouch();
	bool init();
	~CCLayer();
	bool isTouchEnabled();
	CCScriptHandlerEntry* getScriptAccelerateHandlerEntry();
	CCScriptHandlerEntry* getScriptKeypadHandlerEntry();
	void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	void setTouchEnabled(bool value);
	void unregisterScriptKeypadHandler();
	void setSwallowTouch(bool flag);
	bool isKeypadEnabled();
	void ccTouchesEnded(CCSet* pTouches, CCEvent* pEvent);
	void setTouchMode(ccTouchesMode mode);
	bool isAccelerometerEnabled();
	void onExit();
	void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	void registerScriptTouchHandler(int nHandler, bool bIsMultiTouches, int nPriority, bool bSwallowsTouches);
	void ccTouchCancelled(CCTouch* pTouch, CCEvent* pEvent);
	CCTouchScriptHandlerEntry* getScriptTouchHandlerEntry();
	void ccTouchesBegan(CCSet* pTouches, CCEvent* pEvent);
	void setTouchPriority(int priority);
	int getTouchPriority();
	void setKeypadEnabled(bool value);
	void registerWithTouchDispatcher();
	void keyMenuClicked();
	void onEnterTransitionDidFinish();
	void registerScriptKeypadHandler(int nHandler);
};
class CCJSONArray : public CCObject {
	static CCJSONArray* create @ createpccul(const char* json, unsigned long length);
	static CCJSONArray* create @ create();
	static CCJSONArray* create @ creatercs(const string& path);
	void addArray(CCJSONArray* ja);
	void addObject(CCJSONObject* jo);
	void addDouble(double d);
	bool optBool(int index, bool def);
	double optDouble(int index, double def);
	void addLong(long l);
	int getLength();
	long optLong(int index, long def);
	~CCJSONArray();
	CCJSONArray* optJSONArray(int index);
	CCJSONObject* optJSONObject(int index);
	void addInt(int i);
	float optFloat(int index, float def);
	string toString();
	void addNull();
	int optInt(int index, int def);
	void output(CCAssetOutputStream* aos, int level);
	void addBool(bool b);
	void addString(const char* s);
	string optString(int index, const char* def);
	void addFloat(float f);
};
class CCTurnOffTiles : public CCTiledGrid3DAction {
	static CCTurnOffTiles* create @ createfrcCui(float duration, const CCSize& gridSize, unsigned int seed);
	static CCTurnOffTiles* create @ createfrcC(float duration, const CCSize& gridSize);
	void turnOnTile(const CCPoint& pos);
	void startWithTarget(CCNode* pTarget);
	void turnOffTile(const CCPoint& pos);
	void shuffle(unsigned int* pArray, unsigned int nLen);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCSize& gridSize, unsigned int seed);
	void update(float time);
	~CCTurnOffTiles();
};
class CCMemoryInputStream : public CCAssetInputStream {
	static CCMemoryInputStream* create(char* buffer, unsigned long length, bool release);
	unsigned long available();
	int read(char* buffer, unsigned long length);
	unsigned long getLength();
	~CCMemoryInputStream();
	void close();
	char* getBuffer();
	unsigned long seek(int offset, int mode);
	unsigned long getPosition();
};
class CCTableViewDataSource {
	unsigned int numberOfCellsInTableView(CCTableView* table);
	CCTableViewCell* tableCellAtIndex(CCTableView* table, unsigned int idx);
	CCSize tableCellSizeForIndex(CCTableView* table, unsigned int idx);
	~CCTableViewDataSource();
};
class InnerActionFrame : public Frame {
	static InnerActionFrame* create();
	int getStartFrameIndex();
	void onEnter(Frame* nextFrame);
	InnerActionType getInnerActionType();
	Frame* clone();
	void setStartFrameIndex(int frameIndex);
	void setInnerActionType(InnerActionType type);
};
class CCArcticManager : public CCObject {
	static CCArcticManager* getInstance();
	CCArcticFileData* load(const char* asPath);
	void releaseAllAnimationFileData();
	CCAFCAnimation* getAnimationData(CCArcticFileData* afd, int animIndex, CCAFCClipMapping* mapping);
	~CCArcticManager();
};
class CCEaseQuadraticActionOut : public CCActionEase {
	static CCEaseQuadraticActionOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCSpriteDisplayData : public CCDisplayData {
	CCBaseData skinData;
	static CCSpriteDisplayData* create();
	void copy(CCDisplayData* displayData);
	~CCSpriteDisplayData();
};
class CCTexturePVR : public CCObject {
	static CCTexturePVR* create(const char* path);
	bool initWithContentsOfFile(const char* path);
	bool isForcePremultipliedAlpha();
	bool hasAlpha();
	unsigned int getName();
	void setRetainName(bool retainName);
	unsigned int getHeight();
	~CCTexturePVR();
	unsigned int getWidth();
	bool hasPremultipliedAlpha();
	CCTexture2DPixelFormat getFormat();
	unsigned int getNumberOfMipmaps();
	bool isRetainName();
};
class CCMWSprite : public CCAFCSprite {
	int getAnimationCount();
	CCAFCAnimation* getAnimationAt(int index, CCAFCClipMapping* mapping);
	CCAFCFileData* getFileData();
	int getImageCount();
	~CCMWSprite();
};
class RelativeLayoutParameter : public LayoutParameter {
	static RelativeLayoutParameter* create();
	void setAlign(RelativeAlign align);
	void copyProperties(LayoutParameter* model);
	~RelativeLayoutParameter();
	void setRelativeToWidgetName(const char* name);
	const char* getRelativeName();
	const char* getRelativeToWidgetName();
	void setRelativeName(const char* name);
	RelativeAlign getAlign();
	LayoutParameter* createCloneInstance();
};
class CCSet : public CCObject {
	static CCSet* create();
	int count();
	void addObject(CCObject* pObject);
	void acceptVisitor(CCDataVisitor& visitor);
	CCSet* mutableCopy();
	CCObject* anyObject();
	~CCSet();
	void removeAllObjects();
	void removeObject(CCObject* pObject);
	CCSet* copy();
	bool containsObject(CCObject* pObject);
};
class CCSpriteFrameCache : public CCObject {
	static void purgeSharedSpriteFrameCache();
	static CCSpriteFrameCache* sharedSpriteFrameCache();
	void addSpriteFramesWithFile @ addSpriteFramesWithFilepccpcc(const char* plist, const char* textureFileName);
	void addSpriteFramesWithFile @ addSpriteFramesWithFilepcc(const char* pszPlist);
	void addSpriteFramesWithFile @ addSpriteFramesWithFilepccpC(const char* pszPlist, CCTexture2D* pobTexture);
	void addSpriteFrame(CCSpriteFrame* pobFrame, const char* pszFrameName);
	CCSpriteFrame* spriteFrameByName(const char* pszName);
	void removeUnusedSpriteFrames();
	~CCSpriteFrameCache();
	void removeSpriteFramesFromFile(const char* plist);
	bool init();
	void removeSpriteFrames();
	void removeSpriteFramesFromTexture(CCTexture2D* texture);
	void removeSpriteFrameByName(const char* pszName);
};
class CCTextFieldDelegate {
	bool onTextFieldAttachWithIME(CCTextFieldTTF* sender);
	bool onTextFieldDeleteBackward(CCTextFieldTTF* sender, const char* delText, int nLen);
	bool onDraw(CCTextFieldTTF* sender);
	bool onTextFieldInsertText(CCTextFieldTTF* sender, const char* text, int nLen);
	bool onTextFieldDetachWithIME(CCTextFieldTTF* sender);
};
class CCEditBox : public CCControlButton, public CCIMEDelegate {
	static CCEditBox* create(const CCSize& size, CCScale9Sprite* pNormal9SpriteBg, CCScale9Sprite* pPressed9SpriteBg, CCScale9Sprite* pDisabled9SpriteBg);
	void setAnchorPoint(const CCPoint& anchorPoint);
	void onEnter();
	void keyboardDidShow(CCIMEKeyboardNotificationInfo& info);
	int getScriptEditBoxHandler();
	const char* getText();
	void keyboardDidHide(CCIMEKeyboardNotificationInfo& info);
	void setPlaceholderFontName(const char* pFontName);
	const char* getPlaceHolder();
	void setFontName(const char* pFontName);
	void registerScriptEditBoxHandler(int handler);
	void visit();
	void setPlaceholderFontSize(int fontSize);
	~CCEditBox();
	void setInputMode(EditBoxInputMode inputMode);
	void unregisterScriptEditBoxHandler();
	void keyboardWillShow(CCIMEKeyboardNotificationInfo& info);
	void setPlaceholderFontColor(const ccColor3B& color);
	void setFontColor(const ccColor3B& color);
	void keyboardWillHide(CCIMEKeyboardNotificationInfo& info);
	void touchDownAction(CCObject* sender, unsigned int controlEvent);
	void setPlaceholderFont(const char* pFontName, int fontSize);
	void setDelegate(CCEditBoxDelegate* pDelegate);
	void setFontSize(int fontSize);
	bool initWithSizeAndBackgroundSprite(const CCSize& size, CCScale9Sprite* pNormal9SpriteBg);
	void setPlaceHolder(const char* pText);
	void setPosition(const CCPoint& pos);
	void setReturnType(KeyboardReturnType returnType);
	CCEditBoxDelegate* getDelegate();
	void setInputFlag(EditBoxInputFlag inputFlag);
	int getMaxLength();
	void setText(const char* pText);
	void onExit();
	void setMaxLength(int maxLength);
	void setContentSize(const CCSize& size);
	void setFont(const char* pFontName, int fontSize);
	void setVisible(bool visible);
};
class RichElementCustomNode : public RichElement {
	static RichElementCustomNode* create(int tag, const ccColor3B& color, unsigned char opacity, CCNode* customNode);
	bool init(int tag, const ccColor3B& color, unsigned char opacity, CCNode* customNode);
	~RichElementCustomNode();
};
class CCTransitionProgressOutIn : public CCTransitionProgress {
	static CCTransitionProgressOutIn* create(float t, CCScene* scene);
};
class CCDirectorDelegate {
	void updateProjection();
};
class CCNode : public CCObject {
	static CCNode* create();
	void addChild @ addChildpCi(CCNode* child, int zOrder);
	void addChild @ addChildpC(CCNode* child);
	void addChild @ addChildpCii(CCNode* child, int zOrder, int tag);
	bool removeComponent @ removeComponentpC(CCComponent* pComponent);
	bool removeComponent @ removeComponentpcc(const char* pName);
	CCAffineTransform nodeToWorldTransform();
	void removeAllComponents();
	CCGLProgram* getShaderProgram();
	CCObject* getUserObject();
	CCArray* getChildren();
	int getScriptHandler();
	CCPoint convertToWorldSpaceAR(const CCPoint& nodePoint);
	bool isIgnoreAnchorPointForPosition();
	bool init();
	void setRotation(float fRotation);
	void setZOrder(int zOrder);
	void setScaleY(float fScaleY);
	void setScaleX(float fScaleX);
	void scheduleUpdateWithPriority(int priority);
	void unregisterScriptHandler();
	int getTag();
	void onExit();
	void removeChild @ removeChildpCb(CCNode* child, bool cleanup);
	void removeChild @ removeChildpC(CCNode* child);
	CCPoint convertToWorldSpace(const CCPoint& nodePoint);
	void setSkewX(float fSkewX);
	void setSkewY(float fSkewY);
	void onEnterTransitionDidFinish();
	CCPoint convertTouchToNodeSpace(CCTouch* touch);
	void removeAllChildren();
	float getRotationX();
	float getRotationY();
	const char* description();
	void unscheduleUpdate();
	void* getUserData();
	void setParent(CCNode* parent);
	CCAffineTransform nodeToParentTransform();
	void unscheduleAllSelectors();
	void removeAllChildrenWithCleanup(bool cleanup);
	CCGridBase* getGrid();
	unsigned int numberOfRunningActions();
	void removeFromParentAndCleanup(bool cleanup);
	void setPosition @ setPositionff(float x, float y);
	void setPosition @ setPositionrcC(const CCPoint& position);
	void stopActionByTag(int tag);
	void reorderChild(CCNode* child, int zOrder);
	void setGLServerState(ccGLServerState glServerState);
	void setPositionY(float y);
	void setPositionX(float x);
	const CCPoint& getAnchorPoint();
	void updateTransform();
	bool isVisible();
	unsigned int getChildrenCount();
	void setAnchorPoint(const CCPoint& anchorPoint);
	void onEnter();
	CCPoint convertToNodeSpaceAR(const CCPoint& worldPoint);
	bool addComponent(CCComponent* pComponent);
	void visit();
	void setShaderProgram(CCGLProgram* pShaderProgram);
	void scheduleUpdateWithPriorityLua(int nHandler, int priority);
	float getRotation();
	void resumeSchedulerAndActions();
	int getZOrder();
	const CCPoint& getAnchorPointInPoints();
	CCAction* runAction(CCAction* action);
	void transform();
	void setVertexZ(float vertexZ);
	~CCNode();
	void setScheduler(CCScheduler* scheduler);
	void stopAllActions();
	float getSkewX();
	float getSkewY();
	void ignoreAnchorPointForPosition(bool ignore);
	CCAction* getActionByTag(int tag);
	void setRotationX(float fRotaionX);
	void setRotationY(float fRotationY);
	void setAdditionalTransform(const CCAffineTransform& additionalTransform);
	CCScheduler* getScheduler();
	unsigned int getOrderOfArrival();
	CCRect boundingBox();
	void setContentSize(const CCSize& contentSize);
	void setActionManager(CCActionManager* actionManager);
	void getPosition @ getPositionpfpf(float* x, float* y);
	const CCPoint& getPosition @ getPosition();
	bool isRunning();
	CCNode* getParent();
	float getPositionY();
	float getPositionX();
	void removeChildByTag @ removeChildByTagib(int tag, bool cleanup);
	void removeChildByTag @ removeChildByTagi(int tag);
	void setVisible(bool visible);
	void pauseSchedulerAndActions();
	float getVertexZ();
	void _setZOrder(int z);
	void setScale @ setScaleff(float fScaleX, float fScaleY);
	void setScale @ setScalef(float scale);
	CCNode* getChildByTag(int tag);
	void setOrderOfArrival(unsigned int uOrderOfArrival);
	float getScaleY();
	float getScaleX();
	void cleanup();
	CCComponent* getComponent(const char* pName);
	const CCSize& getContentSize();
	void setGrid(CCGridBase* pGrid);
	void draw();
	void transformAncestors();
	void setUserObject(CCObject* pUserObject);
	void registerScriptHandler(int handler);
	void removeFromParent();
	CCPoint convertTouchToNodeSpaceAR(CCTouch* touch);
	void update(float delta);
	void sortAllChildren();
	CCPoint convertToNodeSpace(const CCPoint& worldPoint);
	void onExitTransitionDidStart();
	float getScale();
	CCAffineTransform worldToNodeTransform();
	void setUserData(void* pUserData);
	CCAffineTransform parentToNodeTransform();
	CCCamera* getCamera();
	void setTag(int nTag);
	void scheduleUpdate();
	ccGLServerState getGLServerState();
	void stopAction(CCAction* action);
	CCActionManager* getActionManager();
};
class CCKeypadDelegate {
	void keyBackClicked();
	void keyMenuClicked();
};
class CCSize {
	float width;
	float height;
	void setSize(float width, float height);
	bool equals(const CCSize& target);
	CCSize(float width, float height);
	CCSize();
	CCSize(const CCSize& other);
	CCSize(const CCPoint& point);
};
class ActionTimeline : public CCAction {
	static ActionTimeline* create();
	void setScriptObjectDict(CCDictionary* scriptObjectDict);
	void addTimeline(Timeline* timeline);
	int getCurrentFrame();
	int getStartFrame();
	void pause();
	~ActionTimeline();
	bool init();
	void removeTimeline(Timeline* timeline);
	bool isDone();
	void resume();
	ActionTimeline* clone();
	CCDictionary* getScriptObjectDict();
	void step(float delta);
	float getTimeSpeed();
	int getDuration();
	void gotoFrameAndPause(int startIndex);
	bool isPlaying();
	void gotoFrameAndPlay @ gotoFrameAndPlayib(int startIndex, bool loop);
	void gotoFrameAndPlay @ gotoFrameAndPlayi(int startIndex);
	void gotoFrameAndPlay @ gotoFrameAndPlayiib(int startIndex, int endIndex, bool loop);
	void gotoFrameAndPlay @ gotoFrameAndPlayiiib(int startIndex, int endIndex, int currentFrameIndex, bool loop);
	void clearFrameEventCallFunc();
	void startWithTarget(CCNode* target);
	ActionTimeline* reverse();
	int getEndFrame();
	void setTimeSpeed(float speed);
	void setDuration(int duration);
	void setCurrentFrame(int frameIndex);
};
class CCLayerColor : public CCLayerRGBA, public CCBlendProtocol {
	static CCLayerColor* create @ createrccff(const ccColor4B& color, float width, float height);
	static CCLayerColor* create @ create();
	static CCLayerColor* create @ creatercc(const ccColor4B& color);
	void draw();
	ccBlendFunc getBlendFunc();
	void setColor(const ccColor3B& color);
	void setBlendFunc(ccBlendFunc var);
	void changeWidth(float w);
	void changeWidthAndHeight(float w, float h);
	~CCLayerColor();
	bool init();
	bool initWithColor @ initWithColorrcc(const ccColor4B& color);
	bool initWithColor @ initWithColorrccff(const ccColor4B& color, float width, float height);
	void setOpacity(unsigned char opacity);
	void setContentSize(const CCSize& var);
	void changeHeight(float h);
};
class CCTargetedTouchDelegate : public CCTouchDelegate {
	void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	void ccTouchCancelled(CCTouch* pTouch, CCEvent* pEvent);
};
class CCEaseCubicActionIn : public CCActionEase {
	static CCEaseCubicActionIn* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCSchedulerScriptHandlerEntry : public CCScriptHandlerEntry {
	static CCSchedulerScriptHandlerEntry* create(int nHandler, float fInterval, bool bPaused);
	bool isMarkedForDeletion();
	void markedForDeletion();
	CCTimer* getTimer();
	bool isPaused();
	~CCSchedulerScriptHandlerEntry();
};
class Widget : public CCNodeRGBA {
	static Widget* create();
	void addChild @ addChildpCi(CCNode* child, int zOrder);
	void addChild @ addChildpC(CCNode* child);
	void addChild @ addChildpCii(CCNode* child, int zOrder, int tag);
	CCNode* getVirtualRenderer();
	const CCSize& getCustomSize();
	void setActionTag(int tag);
	string getDescription();
	const CCSize& getSize();
	CCArray* getChildren();
	void onTouchEnded(CCTouch* touch, CCEvent* unused_event);
	PositionType getPositionType();
	Widget* getChildByName(const char* name);
	bool isEnabled();
	bool isFlipX();
	bool isFlipY();
	void removeNodeByTag(int tag);
	void didNotSelectSelf();
	void setFocused(bool fucosed);
	LayoutParameter* getLayoutParameter(LayoutParameterType type);
	const ccColor3B& getColor();
	bool isBright();
	void updateSizeAndPosition @ updateSizeAndPositionrcC(const CCSize& parentSize);
	void updateSizeAndPosition @ updateSizeAndPosition();
	SizeType getSizeType();
	void onExit();
	const CCPoint& getPositionPercent();
	void removeChild @ removeChildpCb(CCNode* child, bool cleanup);
	void removeChild @ removeChildpC(CCNode* child);
	void moveEvent();
	void setSize(const CCSize& size);
	void removeAllChildren();
	void releaseUpEvent();
	const CCPoint& getSizePercent();
	const CCSize& getLayoutSize();
	void setPositionType(PositionType type);
	const CCSize& getContentSize();
	const char* getName();
	bool isTouchEnabled();
	void setTouchEnabled(bool enabled);
	void setLayoutParameter(LayoutParameter* parameter);
	void removeAllChildrenWithCleanup(bool cleanup);
	bool onTouchBegan(CCTouch* touch, CCEvent* unused_event);
	bool clippingParentAreaContainPoint(const CCPoint& pt);
	void removeFromParentAndCleanup(bool cleanup);
	void setPosition(const CCPoint& pos);
	void setColor(const ccColor3B& color);
	void removeAllNodes();
	bool isFocused();
	unsigned int getChildrenCount();
	void onEnter();
	float getLeftInParent();
	void setPositionPercent(const CCPoint& percent);
	CCArray* getNodes();
	void addNode @ addNodepCi(CCNode* node, int zOrder);
	void addNode @ addNodepC(CCNode* node);
	void addNode @ addNodepCii(CCNode* node, int zOrder, int tag);
	float getBottomInParent();
	void ignoreContentAdaptWithSize(bool ignore);
	void visit();
	~Widget();
	void setEnabled(bool enabled);
	void removeNode(CCNode* node);
	void setBrightStyle(BrightStyle style);
	void setName(const char* name);
	void setFlipY(bool flipY);
	void setFlipX(bool flipX);
	void onTouchCancelled(CCTouch* touch, CCEvent* unused_event);
	CCNode* getNodeByTag(int tag);
	void removeChildByTag(int tag, bool cleanup);
	bool hitTest(const CCPoint& pt);
	void setSizePercent(const CCPoint& percent);
	void setScriptObjectDict(CCDictionary* scriptObjectDict);
	const CCPoint& getTouchEndPos();
	CCNode* getChildByTag(int tag);
	bool isIgnoreContentAdaptWithSize();
	void pushDownEvent();
	WidgetType getWidgetType();
	void setOpacity(unsigned char opacity);
	int getActionTag();
	unsigned char getOpacity();
	void cancelUpEvent();
	const CCPoint& getTouchMovePos();
	void onTouchMoved(CCTouch* touch, CCEvent* unused_event);
	void removeFromParent();
	CCPoint getWorldPosition();
	Widget* clone();
	void sortAllChildren();
	void checkChildInfo(int handleState, Widget* sender, const CCPoint& touchPoint);
	float getTopInParent();
	CCDictionary* getScriptObjectDict();
	float getRightInParent();
	const CCPoint& getTouchStartPos();
	void setSizeType(SizeType type);
	void setBright(bool bright);
};
class CCSPX3Frame : public CCObject {
	int m_flags;
	CCSPX3Tile m_rect;
	int m_patchCount;
	int m_collisionCount;
	static CCSPX3Frame* create();
	~CCSPX3Frame();
};
class CCLabelTTF : public CCGradientSprite, public CCLabelProtocol {
	void enableShadow(const CCSize& shadowOffset, int shadowColor, float shadowBlur, bool mustUpdateTexture);
	void setDimensions(const CCSize& dim);
	float getFontSize();
	const char* getString();
	void setGlobalImageScaleFactor(float scale, bool mustUpdateTexture);
	void stopLoopDisplay();
	float getGlobalImageScaleFactor();
	void setFontName(const char* fontName);
	void setLineSpacing(float s, bool mustUpdateTexture);
	CCTextAlignment getHorizontalAlignment();
	void setString(const char* label);
	~CCLabelTTF();
	CCRect getImageBoundInWorldSpace(int index);
	CCRect getImageBoundInParentSpace(int index);
	void setLinkTargetForAll(CCCallFunc* func);
	const char* getFontName();
	float getLineSpacing();
	const char* description();
	void enableStroke(const ccColor3B& strokeColor, float strokeSize, bool mustUpdateTexture);
	void update(float delta);
	CCSize getDimensions();
	void setVerticalAlignment(CCVerticalTextAlignment verticalAlignment);
	void setFontSize(float fontSize);
	CCVerticalTextAlignment getVerticalAlignment();
	void setLinkTarget(int index, CCCallFunc* func);
	CCRect getImageBound(int index);
	void setColor @ setColorrccb(const ccColor3B& tintColor, bool mustUpdateTexture);
	void setColor @ setColorrcc(const ccColor3B& color3);
	void setColor @ setColorrccrccrcC(const ccColor4B& start, const ccColor4B& end, const CCPoint& v);
	void setLinkPriority(int p);
	void setDisplayTo(int to);
	void setHorizontalAlignment(CCTextAlignment alignment);
	void disableShadow(bool mustUpdateTexture);
	void startLoopDisplay(float interval, unsigned int repeat, int delay, CCCallFunc* loopFunc);
	void disableStroke(bool mustUpdateTexture);
};
class RotationSkewFrame : public SkewFrame {
	static RotationSkewFrame* create();
	void apply(float percent);
	Frame* clone();
	void onEnter(Frame* nextFrame);
};
class CCTransitionPageTurn : public CCTransitionScene {
	static CCTransitionPageTurn* create(float t, CCScene* scene, bool backwards);
	CCActionInterval* actionWithSize(const CCSize& vector);
	~CCTransitionPageTurn();
	void onEnter();
	bool initWithDuration(float t, CCScene* scene, bool backwards);
};
class CCTransitionRotoZoom : public CCTransitionScene {
	static CCTransitionRotoZoom* create(float t, CCScene* scene);
	~CCTransitionRotoZoom();
	void onEnter();
};
class RichElementText : public RichElement {
	static RichElementText* create(int tag, const ccColor3B& color, unsigned char opacity, const char* text, const char* fontName, float fontSize);
	bool init(int tag, const ccColor3B& color, unsigned char opacity, const char* text, const char* fontName, float fontSize);
	~RichElementText();
};
class CCDelayTime : public CCActionInterval {
	static CCDelayTime* create(float d);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCTiledSprite : public CCSprite {
	static CCTiledSprite* create(const char* fileImage);
	static CCTiledSprite* createWithSprite(CCSprite* sprite);
	static CCTiledSprite* createWithTexture(CCTexture2D* tex);
	static CCTiledSprite* createWithSpriteFrameName(const char* name);
	static CCTiledSprite* createWithSpriteFrame(CCSpriteFrame* frame);
	void setHeight(float h);
	void draw();
	bool initWithTexture(CCTexture2D* pTexture, const CCRect& rect, bool rotated);
	void setOpacity(unsigned char opacity);
	~CCTiledSprite();
	void setDisplayFrame(CCSpriteFrame* pNewFrame);
	void setWidth(float w);
	void setContentSize(const CCSize& contentSize);
};
class CCHttpClient : public CCObject {
	static CCHttpClient* create();
	void setReadTimeout(float var);
	void cancelAll();
	~CCHttpClient();
	bool init();
	float getConnectTimeout();
	void cancel(int tag);
	void setConnectTimeout(float var);
	float getReadTimeout();
	void asyncExecute(CCHttpRequest* request);
};
class CCFadeOutDownTiles : public CCFadeOutUpTiles {
	static CCFadeOutDownTiles* create(float duration, const CCSize& gridSize);
	float testFunc(const CCSize& pos, float time);
};
class CCAction : public CCObject {
	static CCAction* create();
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	void setOriginalTarget(CCNode* pOriginalTarget);
	void setTarget(CCNode* pTarget);
	CCNode* getOriginalTarget();
	void stop();
	void update(float time);
	CCNode* getTarget();
	~CCAction();
	void step(float dt);
	void setTag(int nTag);
	int getTag();
	bool isDone();
	const char* description();
};
class CCAccelDeccelAmplitude : public CCActionInterval {
	static CCAccelDeccelAmplitude* create(CCAction* pAction, float duration);
	void startWithTarget(CCNode* pTarget);
	CCActionInterval* reverse();
	float getRate();
	void update(float time);
	void setRate(float fRate);
	bool initWithAction(CCAction* pAction, float duration);
	~CCAccelDeccelAmplitude();
};
class CCMoveTo : public CCMoveBy {
	static CCMoveTo* create(float duration, const CCPoint& position, bool autoHeadOn, float initAngle);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCPoint& position, bool autoHeadOn, float initAngle);
};
class CCPageTurn3D : public CCGrid3DAction {
	static CCPageTurn3D* create(float duration, const CCSize& gridSize);
	void update(float time);
};
class CCBMFontConfiguration : public CCObject {
	int m_nCommonHeight;
	ccBMFontPadding m_tPadding;
	string m_sAtlasName;
	static CCBMFontConfiguration* create(const char* FNTfile);
	const char* description();
	const char* getAtlasName();
	~CCBMFontConfiguration();
	void setAtlasName(const char* atlasName);
	bool initWithFNTfile(const char* FNTfile);
};
class CCEGLView : public CCEGLViewProtocol {
	static CCEGLView* sharedOpenGLView();
	void swapBuffers();
	void end();
	~CCEGLView();
	void setIMEKeyboardState(bool bOpen);
	bool isOpenGLReady();
};
class CCEvent : public CCObject {
};
class CCProfiler : public CCObject {
	static CCProfiler* sharedProfiler();
	void displayTimers();
	void releaseTimer(const char* timerName);
	~CCProfiler();
	bool init();
	void releaseAllTimers();
	CCProfilingTimer* createAndAddTimerWithName(const char* timerName);
};
class CCFileUtils : public TypeInfo {
	static void purgeFileUtils();
	static CCFileUtils* sharedFileUtils();
	bool isFileExist(const string& strFilePath);
	void removeSearchPath(const char* path);
	void purgeCachedEntries();
	const char* fullPathFromRelativeFile(const char* pszFilename, const char* pszRelativeFile);
	unsigned char* getFileData(const char* pszFileName, const char* pszMode, unsigned long* pSize);
	bool isPopupNotify();
	void setFilenameLookupDictionary(CCDictionary* pFilenameLookupDict);
	void addSearchResolutionsOrder(const char* order);
	unsigned char* getFileDataFromZip(const char* pszZipFilePath, const char* pszFileName, unsigned long* pSize);
	~CCFileUtils();
	long getClassTypeInfo();
	void removeAllPaths();
	string fullPathForFilename(const char* pszFileName);
	bool isAbsolutePath(const string& strPath);
	void addSearchPath(const char* path);
	void loadFilenameLookupDictionaryFromFile(const char* filename);
	string getWritablePath();
	void setPopupNotify(bool bNotify);
};
class CCMotionStreak : public CCNodeRGBA, public CCTextureProtocol {
	static CCMotionStreak* create @ createfffrccpC(float fade, float minSeg, float stroke, const ccColor3B& color, CCTexture2D* texture);
	static CCMotionStreak* create @ createfffrccpcc(float fade, float minSeg, float stroke, const ccColor3B& color, const char* path);
	void reset();
	void draw();
	void setTexture(CCTexture2D* texture);
	bool isOpacityModifyRGB();
	void setOpacity(unsigned char opacity);
	CCTexture2D* getTexture();
	void tintWithColor(ccColor3B colors);
	void setBlendFunc(ccBlendFunc blendFunc);
	void update(float delta);
	~CCMotionStreak();
	ccBlendFunc getBlendFunc();
	bool initWithFade @ initWithFadefffrccpC(float fade, float minSeg, float stroke, const ccColor3B& color, CCTexture2D* texture);
	bool initWithFade @ initWithFadefffrccpcc(float fade, float minSeg, float stroke, const ccColor3B& color, const char* path);
	bool isFastMode();
	void setOpacityModifyRGB(bool bValue);
	unsigned char getOpacity();
	void setPosition(const CCPoint& position);
	void setStartingPositionInitialized(bool bStartingPositionInitialized);
	void setFastMode(bool bFastMode);
	bool isStartingPositionInitialized();
};
class AnchorPointFrame : public Frame {
	static AnchorPointFrame* create();
	void setAnchorPoint(const CCPoint& point);
	Frame* clone();
	void onEnter(Frame* nextFrame);
	CCPoint getAnchorPoint();
};
class CCClippingNode : public CCNode {
	static CCClippingNode* create @ createpC(CCNode* pStencil);
	static CCClippingNode* create @ create();
	void onEnter();
	void onExit();
	void setInverted(bool bInverted);
	void visit();
	void setStencil(CCNode* pStencil);
	~CCClippingNode();
	float getAlphaThreshold();
	bool init @ initpC(CCNode* pStencil);
	bool init @ init();
	void onExitTransitionDidStart();
	CCNode* getStencil();
	void setAlphaThreshold(float fAlphaThreshold);
	void onEnterTransitionDidFinish();
	bool isInverted();
};
class CCTweenFunction {
	static float quartEaseInOut(float time);
	static float backEaseIn(float time);
	static float quintEaseIn(float time);
	static float tweenTo(float time, CCTweenType type, float* easingParam);
	static float cubicEaseOut(float time);
	static float bounceEaseInOut(float time);
	static float bounceEaseOut(float time);
	static float quartEaseOut(float time);
	static float expoEaseOut(float time);
	static float circEaseInOut(float time);
	static float sineEaseOut(float time);
	static float backEaseOut(float time);
	static float quintEaseOut(float time);
	static float quintEaseInOut(float time);
	static float backEaseInOut(float time);
	static float elasticEaseInOut(float time, float* easingParam);
	static float bounceEaseIn(float time);
	static float linear(float time);
	static float customEase(float time, float* easingParam);
	static float elasticEaseIn(float time, float* easingParam);
	static float quadEaseOut(float time);
	static float elasticEaseOut(float time, float* easingParam);
	static float circEaseIn(float time);
	static float expoEaseIn(float time);
	static float sineEaseIn(float time);
	static float cubicEaseInOut(float time);
	static float cubicEaseIn(float time);
	static float quadEaseIn(float time);
	static float circEaseOut(float time);
	static float expoEaseInOut(float time);
	static float quartEaseIn(float time);
	static float quadEaseInOut(float time);
	static float sineEaseInOut(float time);
};
class CCFadeIn : public CCActionInterval {
	static CCFadeIn* create(float d);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCMissile : public CCActionInterval {
	static CCMissile* create(float velocity, CCNode* aimed, float targetPresetDegree, CCCallFunc* doneCallFunc);
	CCObject* copyWithZone(CCZone* pZone);
	~CCMissile();
	void step(float dt);
	bool isDone();
	bool initWithVelocity(float velocity, CCNode* aimed, float targetPresetDegree, CCCallFunc* doneCallFunc);
};
class CCTileMapAtlas : public CCAtlasNode {
	static CCTileMapAtlas* create(const char* tile, const char* mapFile, int tileWidth, int tileHeight);
	bool initWithTileFile(const char* tile, const char* mapFile, int tileWidth, int tileHeight);
	void releaseMap();
	ccColor3B tileAt(const CCPoint& position);
	~CCTileMapAtlas();
	tImageTGA* getTGAInfo();
	void setTile(const ccColor3B& tile, const CCPoint& position);
	void setTGAInfo(tImageTGA* var);
};
class CCControlSaturationBrightnessPicker : public CCControl {
	static CCControlSaturationBrightnessPicker* create(CCNode* target, CCPoint pos);
	CCSprite* getShadow();
	bool initWithTargetAndPos(CCNode* target, CCPoint pos);
	CCPoint getStartPos();
	CCSprite* getOverlay();
	void setEnabled(bool enabled);
	CCSprite* getSlider();
	void updateWithHSV(HSV hsv);
	~CCControlSaturationBrightnessPicker();
	CCSprite* getBackground();
	void updateDraggerWithHSV(HSV hsv);
	float getSaturation();
	float getBrightness();
};
class CCPointArray : public CCObject {
	static CCPointArray* create(unsigned int capacity);
	unsigned int count();
	void insertControlPoint(CCPoint& controlPoint, unsigned int index);
	CCPointArray* reverse();
	bool initWithCapacity(unsigned int capacity);
	void removeControlPointAtIndex(unsigned int index);
	~CCPointArray();
	void replaceControlPoint(CCPoint& controlPoint, unsigned int index);
	void addControlPoint(CCPoint controlPoint);
	CCPoint getControlPointAtIndex(unsigned int index);
	void reverseInline();
	CCObject* copyWithZone(CCZone* zone);
};
class CCTextureProtocol : public CCBlendProtocol {
	void setTexture(CCTexture2D* texture);
	CCTexture2D* getTexture();
};
class CCMenuItemFont : public CCMenuItemLabel {
	static void setFontName(const char* name);
	static const char* fontName();
	static unsigned int fontSize();
	static CCMenuItemFont* create(const char* value);
	static void setFontSize(unsigned int s);
	~CCMenuItemFont();
	const char* fontNameObj();
	void setFontNameObj(const char* name);
	unsigned int fontSizeObj();
	void setFontSizeObj(unsigned int s);
};
class CCSPXFrame : public CCObject {
	int m_width;
	int m_height;
	int m_frameTileCount;
	int m_collisionCount;
	int m_referencePointCount;
	~CCSPXFrame();
};
class CCTouchDispatcher : public CCObject, public EGLTouchDelegate {
	void touches(CCSet* pTouches, CCEvent* pEvent, unsigned int uIndex);
	void touchesEnded(CCSet* touches, CCEvent* pEvent);
	void addStandardDelegate(CCTouchDelegate* pDelegate, int nPriority);
	bool isDispatchEvents();
	void setPriority(int nPriority, CCTouchDelegate* pDelegate);
	void touchesCancelled(CCSet* touches, CCEvent* pEvent);
	void setDispatchEvents(bool bDispatchEvents);
	void touchesMoved(CCSet* touches, CCEvent* pEvent);
	~CCTouchDispatcher();
	bool init();
	void addTargetedDelegate(CCTouchDelegate* pDelegate, int nPriority, bool bSwallowsTouches);
	CCTouchHandler* findHandler(CCTouchDelegate* pDelegate);
	void touchesBegan(CCSet* touches, CCEvent* pEvent);
	void removeDelegate(CCTouchDelegate* pDelegate);
	void removeAllDelegates();
};
class CCSpriteFrameCacheHelper {
	static void purge();
	static CCSpriteFrameCacheHelper* sharedSpriteFrameCacheHelper();
	void addSpriteFrameFromFile(const char* plistPath, const char* imagePath);
	~CCSpriteFrameCacheHelper();
};
class CCDisplayLinkDirector : public CCDirector {
	void startAnimation();
	void mainLoop();
	void stopAnimation();
	void setAnimationInterval(double dValue);
};
class VisibleFrame : public Frame {
	static VisibleFrame* create();
	void setVisible(bool visible);
	Frame* clone();
	bool isVisible();
	void onEnter(Frame* nextFrame);
};
class CCArcticFileData : public CCAFCFileData {
	int m_version;
	int m_flags;
	int m_moduleCount;
	int m_frameModuleCount;
	int m_frameCount;
	int m_animationFrameCount;
	int m_animationCount;
	static CCArcticFileData* create();
	~CCArcticFileData();
};
class CCEaseQuadraticActionInOut : public CCActionEase {
	static CCEaseQuadraticActionInOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCAuroraFileData : public CCAFCFileData {
	int m_version;
	int m_flags;
	int m_imageCount;
	int m_moduleCount;
	int m_frameModuleCount;
	int m_collisionRectCount;
	int m_frameCount;
	int m_animationFrameCount;
	int m_animationCount;
	static CCAuroraFileData* create();
	~CCAuroraFileData();
};
class CCTransitionMoveInR : public CCTransitionMoveInL {
	static CCTransitionMoveInR* create(float t, CCScene* scene);
	~CCTransitionMoveInR();
	void initScenes();
};
class CCTransitionMoveInT : public CCTransitionMoveInL {
	static CCTransitionMoveInT* create(float t, CCScene* scene);
	~CCTransitionMoveInT();
	void initScenes();
};
class CCArmatureDataManager : public CCObject {
	static void purge();
	static CCArmatureDataManager* sharedArmatureDataManager();
	CCDictionary* getAnimationDatas();
	void removeAnimationData(const char* id);
	void addArmatureData(const char* id, CCArmatureData* armatureData, const char* configFilePath);
	void addArmatureFileInfo @ addArmatureFileInfopccpccpcc(const char* imagePath, const char* plistPath, const char* configFilePath);
	void addArmatureFileInfo @ addArmatureFileInfopcc(const char* configFilePath);
	void removeArmatureFileInfo(const char* configFilePath);
	CCDictionary* getTextureDatas();
	CCTextureData* getTextureData(const char* id);
	CCArmatureData* getArmatureData(const char* id);
	CCAnimationData* getAnimationData(const char* id);
	~CCArmatureDataManager();
	void addAnimationData(const char* id, CCAnimationData* animationData, const char* configFilePath);
	bool init();
	void removeArmatureData(const char* id);
	CCDictionary* getArmatureDatas();
	void removeTextureData(const char* id);
	void addTextureData(const char* id, CCTextureData* textureData, const char* configFilePath);
	bool isAutoLoadSpriteFile();
	void addSpriteFrameFromFile(const char* plistPath, const char* imagePath, const char* configFilePath);
};
class CCStopGrid : public CCActionInstant {
	static CCStopGrid* create();
	void startWithTarget(CCNode* pTarget);
};
class CCSpriteBatchNode : public CCNode, public CCTextureProtocol {
	static CCSpriteBatchNode* create @ createpcc(const char* fileImage);
	static CCSpriteBatchNode* create @ createpccui(const char* fileImage, unsigned int capacity);
	static CCSpriteBatchNode* createWithTexture @ createWithTexturepC(CCTexture2D* tex);
	static CCSpriteBatchNode* createWithTexture @ createWithTexturepCui(CCTexture2D* tex, unsigned int capacity);
	void appendChild(CCSprite* sprite);
	void reorderBatch(bool reorder);
	CCTexture2D* getTexture();
	void visit();
	void insertQuadFromSprite(CCSprite* sprite, unsigned int index);
	void setTexture(CCTexture2D* texture);
	void addChild @ addChildpCi(CCNode* child, int zOrder);
	void addChild @ addChildpC(CCNode* child);
	void addChild @ addChildpCii(CCNode* child, int zOrder, int tag);
	void removeChildAtIndex(unsigned int index, bool doCleanup);
	void removeSpriteFromAtlas(CCSprite* sprite);
	CCSpriteBatchNode* addSpriteWithoutQuad(CCSprite* child, unsigned int z, int aTag);
	unsigned int atlasIndexForChild(CCSprite* sprite, int z);
	void increaseAtlasCapacity();
	~CCSpriteBatchNode();
	bool init();
	void insertChild(CCSprite* child, unsigned int index);
	unsigned int lowestAtlasIndexInChild(CCSprite* sprite);
	void draw();
	ccBlendFunc getBlendFunc();
	bool initWithTexture(CCTexture2D* tex, unsigned int capacity);
	void setTextureAtlas(CCTextureAtlas* textureAtlas);
	void removeAllChildrenWithCleanup(bool cleanup);
	void sortAllChildren();
	void updateQuadFromSprite(CCSprite* sprite, unsigned int index);
	void reorderChild(CCNode* child, int zOrder);
	bool initWithFile(const char* fileImage, unsigned int capacity);
	void setBlendFunc(ccBlendFunc blendFunc);
	unsigned int rebuildIndexInOrder(CCSprite* parent, unsigned int index);
	CCTextureAtlas* getTextureAtlas();
	CCArray* getDescendants();
	void removeChild(CCNode* child, bool cleanup);
	unsigned int highestAtlasIndexInChild(CCSprite* sprite);
};
class CCEaseQuarticActionOut : public CCActionEase {
	static CCEaseQuarticActionOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCTransitionMoveInL : public CCTransitionScene, public CCTransitionEaseScene {
	static CCTransitionMoveInL* create(float t, CCScene* scene);
	void onEnter();
	~CCTransitionMoveInL();
	CCActionInterval* action();
	CCActionInterval* easeActionWithAction(CCActionInterval* action);
	void initScenes();
};
class CCColor3bObject : public CCObject {
	ccColor3B value;
};
class ImageView : public Widget {
	static ImageView* create();
	static CCObject* createInstance();
	void setAnchorPoint(const CCPoint& pt);
	CCNode* getVirtualRenderer();
	void ignoreContentAdaptWithSize(bool ignore);
	void loadTexture(const char* fileName, TextureResType texType);
	string getDescription();
	void setScale9Enabled(bool able);
	~ImageView();
	void setTextureRect(const CCRect& rect);
	void setCapInsets(const CCRect& capInsets);
	const CCRect& getCapInsets();
	const CCSize& getContentSize();
	bool isScale9Enabled();
};
class CCTransitionMoveInB : public CCTransitionMoveInL {
	static CCTransitionMoveInB* create(float t, CCScene* scene);
	~CCTransitionMoveInB();
	void initScenes();
};
class CCTMXLoader : public CCObject, public CCSAXDelegator {
	static CCTMXLoader* create();
	void textHandler(void* ctx, const char* s, int len);
	CCTMXMapInfo* load @ loadpccircs(const char* tmxData, int length, const string& resourcePath);
	CCTMXMapInfo* load @ loadrcs(const string& tmxFile);
	void endElement(void* ctx, const char* name);
	~CCTMXLoader();
};
class CCTransitionZoomFlipX : public CCTransitionSceneOriented {
	static CCTransitionZoomFlipX* create @ createfpC(float t, CCScene* s);
	static CCTransitionZoomFlipX* create @ createfpCt(float t, CCScene* s, tOrientation o);
	~CCTransitionZoomFlipX();
	void onEnter();
};
class CCTransitionZoomFlipY : public CCTransitionSceneOriented {
	static CCTransitionZoomFlipY* create @ createfpC(float t, CCScene* s);
	static CCTransitionZoomFlipY* create @ createfpCt(float t, CCScene* s, tOrientation o);
	~CCTransitionZoomFlipY();
	void onEnter();
};
class CCArrayForObjectSorting : public CCArray {
	void setObjectID_ofSortedObject(unsigned int tag, CCSortableObject* object);
	unsigned int indexOfSortedObject(CCSortableObject* obj);
	void insertSortedObject(CCSortableObject* object);
	CCSortableObject* objectWithObjectID(unsigned int tag);
	void removeSortedObject(CCSortableObject* object);
};
class CCScriptHandlerEntry : public CCObject {
	static CCScriptHandlerEntry* create(int nHandler);
	int getHandler();
	int getEntryId();
	~CCScriptHandlerEntry();
};
class CCAuroraLoader {
	static CCAuroraFileData* load(const char* asPath);
};
class CCHttpResponse : public CCObject {
	const CCDictionary& getHeaders();
	CCData* getData();
	void clearSuccess();
	void setHeaders(const CCDictionary& var);
	int getResponseCode();
	string getHeader(const string& name);
	void setSuccess(bool var);
	CCHttpRequest* getRequest();
	~CCHttpResponse();
	bool isSuccess();
	const CCData& getErrorData();
	void setResponseCode(int var);
	void addHeader(const string& name, const string& value);
	void markSuccess();
	void setErrorData(char* buf);
	void setData(CCData* var);
};
class CCStandardTouchDelegate : public CCTouchDelegate {
	void ccTouchesBegan(CCSet* pTouches, CCEvent* pEvent);
	void ccTouchesCancelled(CCSet* pTouches, CCEvent* pEvent);
	void ccTouchesMoved(CCSet* pTouches, CCEvent* pEvent);
	void ccTouchesEnded(CCSet* pTouches, CCEvent* pEvent);
};
class ActionRotationFrame : public ActionFrame {
	float m_rotation;
	void setRotation(float rotation);
	~ActionRotationFrame();
	CCActionInterval* getAction @ getActionfpA(float fDuration, ActionFrame* srcFrame);
	CCActionInterval* getAction @ getActionf(float fDuration);
	float getRotation();
};
class CCParticleSnow : public CCParticleSystemQuad {
	static CCParticleSnow* create();
	static CCParticleSnow* createWithTotalParticles(unsigned int numberOfParticles);
	bool init();
	~CCParticleSnow();
	bool initWithTotalParticles(unsigned int numberOfParticles);
};
class CCShatteredTiles3D : public CCTiledGrid3DAction {
	static CCShatteredTiles3D* create(float duration, const CCSize& gridSize, int nRange, bool bShatterZ);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCSize& gridSize, int nRange, bool bShatterZ);
	void update(float time);
};
class CCVelocityTracker : public CCObject {
	static CCVelocityTracker* create();
	void addTouchBegan @ addTouchBeganrcC(const CCPoint& pos);
	void addTouchBegan @ addTouchBeganpC(CCTouch* event);
	void computeCurrentVelocity @ computeCurrentVelocityif(int units, float maxVelocity);
	void computeCurrentVelocity @ computeCurrentVelocityi(int units);
	float getYVelocity @ getYVelocityi(int id);
	float getYVelocity @ getYVelocity();
	~CCVelocityTracker();
	float getXVelocity @ getXVelocityi(int id);
	float getXVelocity @ getXVelocity();
	void addTouchMoved @ addTouchMovedrcC(const CCPoint& pos);
	void addTouchMoved @ addTouchMovedpC(CCTouch* event);
};
class CCSpriteFrame : public CCObject {
	static CCSpriteFrame* create @ createpccrcCbrcCrcC(const char* filename, const CCRect& rect, bool rotated, const CCPoint& offset, const CCSize& originalSize);
	static CCSpriteFrame* create @ createpccrcC(const char* filename, const CCRect& rect);
	static CCSpriteFrame* createWithTexture @ createWithTexturepCrcCbrcCrcC(CCTexture2D* pobTexture, const CCRect& rect, bool rotated, const CCPoint& offset, const CCSize& originalSize);
	static CCSpriteFrame* createWithTexture @ createWithTexturepCrcC(CCTexture2D* pobTexture, const CCRect& rect);
	void setRotated(bool bRotated);
	void setTexture(CCTexture2D* pobTexture);
	const CCPoint& getOffset();
	CCObject* copyWithZone(CCZone* pZone);
	void setRectInPixels(const CCRect& rectInPixels);
	CCTexture2D* getTexture();
	const CCRect& getRect();
	void setOffsetInPixels(const CCPoint& offsetInPixels);
	const CCRect& getRectInPixels();
	bool initWithTextureFilename @ initWithTextureFilenamepccrcCbrcCrcC(const char* filename, const CCRect& rect, bool rotated, const CCPoint& offset, const CCSize& originalSize);
	bool initWithTextureFilename @ initWithTextureFilenamepccrcC(const char* filename, const CCRect& rect);
	void setOriginalSize(const CCSize& sizeInPixels);
	const CCSize& getOriginalSizeInPixels();
	void setOriginalSizeInPixels(const CCSize& sizeInPixels);
	void setOffset(const CCPoint& offsets);
	bool initWithTexture @ initWithTexturepCrcCbrcCrcC(CCTexture2D* pobTexture, const CCRect& rect, bool rotated, const CCPoint& offset, const CCSize& originalSize);
	bool initWithTexture @ initWithTexturepCrcC(CCTexture2D* pobTexture, const CCRect& rect);
	bool isRotated();
	~CCSpriteFrame();
	void setRect(const CCRect& rect);
	const CCPoint& getOffsetInPixels();
	const CCSize& getOriginalSize();
};
class CCTween : public CCProcessBase {
	CCTweenType m_eFrameTweenEasing;
	int m_iBetweenDuration;
	int m_iTotalDuration;
	int m_iFromIndex;
	int m_iToIndex;
	bool m_bPassLastFrame;
	static CCTween* create(CCBone* bone);
	void play(CCMovementBoneData* movementBoneData, int durationTo, int durationTween, int loop, int tweenEasing);
	void gotoAndPause(int frameIndex);
	CCMovementBoneData* getMovementBoneData();
	CCArmatureAnimation* getAnimation();
	void setMovementBoneData(CCMovementBoneData* var);
	~CCTween();
	void gotoAndPlay(int frameIndex);
	bool init(CCBone* bone);
	void setAnimation(CCArmatureAnimation* animation);
};
class CCFadeOutTRTiles : public CCTiledGrid3DAction {
	static CCFadeOutTRTiles* create(float duration, const CCSize& gridSize);
	void turnOnTile(const CCPoint& pos);
	void turnOffTile(const CCPoint& pos);
	void transformTile(const CCPoint& pos, float distance);
	float testFunc(const CCSize& pos, float time);
	void update(float time);
};
class CCAtlasNode : public CCNodeRGBA, public CCTextureProtocol {
	bool m_bIsOpacityModifyRGB;
	int m_nUniformColor;
	bool m_bIgnoreContentScaleFactor;
	static CCAtlasNode* create(const char* tile, unsigned int tileWidth, unsigned int tileHeight, unsigned int itemsToRender);
	void setTexture(CCTexture2D* texture);
	void draw();
	ccBlendFunc getBlendFunc();
	bool initWithTileFile(const char* tile, unsigned int tileWidth, unsigned int tileHeight, unsigned int itemsToRender);
	void setColor(const ccColor3B& color);
	void setOpacity(unsigned char opacity);
	void setBlendFunc(ccBlendFunc var);
	void setTextureAtlas(CCTextureAtlas* var);
	CCTexture2D* getTexture();
	CCTextureAtlas* getTextureAtlas();
	~CCAtlasNode();
	unsigned int getQuadsToDraw();
	void updateAtlasValues();
	const ccColor3B& getColor();
	void setOpacityModifyRGB(bool isOpacityModifyRGB);
	bool initWithTexture(CCTexture2D* texture, unsigned int tileWidth, unsigned int tileHeight, unsigned int itemsToRender);
	bool isOpacityModifyRGB();
	void setQuadsToDraw(unsigned int var);
};
class CCDecorativeDisplay : public CCObject {
	static CCDecorativeDisplay* create();
	CCNode* getDisplay();
	~CCDecorativeDisplay();
	void setDisplay(CCNode* var);
	bool init();
	void setDisplayData(CCDisplayData* var);
	CCDisplayData* getDisplayData();
};
class ColorFrame : public Frame {
	static ColorFrame* create();
	void onEnter(Frame* nextFrame);
	void setColor(const ccColor3B& color);
	ccColor3B getColor();
	Frame* clone();
	void setAlpha(unsigned char alpha);
	unsigned char getAlpha();
	void apply(float percent);
};
class CCParticleFire : public CCParticleSystemQuad {
	static CCParticleFire* create();
	static CCParticleFire* createWithTotalParticles(unsigned int numberOfParticles);
	bool init();
	~CCParticleFire();
	bool initWithTotalParticles(unsigned int numberOfParticles);
};
class CCNodeRGBA : public CCNode, public CCRGBAProtocol {
	static CCNodeRGBA* create();
	void updateDisplayedColor(const ccColor3B& parentColor);
	void setColor(const ccColor3B& color);
	bool isCascadeOpacityEnabled();
	const ccColor3B& getColor();
	unsigned char getDisplayedOpacity();
	void setCascadeColorEnabled(bool cascadeColorEnabled);
	void setOpacity(unsigned char opacity);
	~CCNodeRGBA();
	void setCascadeOpacityEnabled(bool cascadeOpacityEnabled);
	void updateDisplayedOpacity(unsigned char parentOpacity);
	bool init();
	void setOpacityModifyRGB(bool bValue);
	unsigned char getOpacity();
	bool isOpacityModifyRGB();
	bool isCascadeColorEnabled();
	const ccColor3B& getDisplayedColor();
};
class CCTMXMapInfo : public CCObject {
	static CCTMXMapInfo* create();
	float getTileWidth();
	void setObjectGroups(const CCArray& var);
	void setTileWidth(float var);
	void setLayers(const CCArray& var);
	CCArray& getTileSets();
	int getMapHeight();
	void setMapWidth(int var);
	CCArray& getLayers();
	float getTileHeight();
	void addTileProperty(int gid, const string& key, const string& value);
	~CCTMXMapInfo();
	int getTileSetIndex(int gid);
	void setProperties(const CCDictionary& var);
	void setTileHeight(float var);
	CCDictionary& getProperties();
	cbTMXOrientation getOrientation();
	void setTileProperties(const CCDictionary& var);
	CCDictionary& getTileProperties @ getTileProperties();
	CCDictionary* getTileProperties @ getTilePropertiesi(int gid);
	void setTileSets(const CCArray& var);
	CCArray& getObjectGroups();
	void setOrientation(cbTMXOrientation var);
	void setTMXFilename(string var);
	void setMapHeight(int var);
	string getProperty(const string& key);
	void addProperty(const string& key, const string& value);
	int getMapWidth();
	string getTileProperty(int gid, const string& key);
	string getTMXFilename();
};
class Timeline : public CCObject {
	static Timeline* create();
	Timeline* clone();
	void gotoFrame(int frameIndex);
	void setNode(CCNode* node);
	ActionTimeline* getActionTimeline();
	void insertFrame(Frame* frame, int index);
	void setActionTag(int tag);
	~Timeline();
	void addFrame(Frame* frame);
	bool init();
	const CCArray* getFrames();
	int getActionTag();
	CCNode* getNode();
	void removeFrame(Frame* frame);
	void setActionTimeline(ActionTimeline* action);
	void stepToFrame(int frameIndex);
};
class CCDictionary : public CCObject {
	static CCDictionary* create();
	static CCDictionary* createWithContentsOfFile(const char* pFileName);
	static CCDictionary* createWithDictionary(CCDictionary* srcDict);
	static CCDictionary* createWithContentsOfFileThreadSafe(const char* pFileName);
	unsigned int count();
	void acceptVisitor(CCDataVisitor& visitor);
	void setObject @ setObjectpCl(CCObject* pObject, long key);
	void setObject @ setObjectpCrcs(CCObject* pObject, const string& key);
	CCObject* copyWithZone(CCZone* pZone);
	void removeObjectForKey @ removeObjectForKeyl(long key);
	void removeObjectForKey @ removeObjectForKeyrcs(const string& key);
	bool writeToFile(const char* fullPath);
	~CCDictionary();
	CCObject* randomObject();
	void removeAllObjects();
	void removeObjectsForKeys(CCArray* pKeyArray);
	const CCString* valueForKey @ valueForKeyl(long key);
	const CCString* valueForKey @ valueForKeyrcs(const string& key);
	CCObject* objectForKey @ objectForKeyl(long key);
	CCObject* objectForKey @ objectForKeyrcs(const string& key);
	void removeObjectForElememt(CCDictElement* pElement);
	CCArray* allKeys();
	CCArray* allKeysForObject(CCObject* object);
};
class CCTransformHelp {
	static void transformFromParentWithoutScale(CCBaseData& node, const CCBaseData& parentNode);
	static void nodeToMatrix(const CCBaseData& _node, CCAffineTransform& _matrix);
	static void transformToParentWithoutScale(CCBaseData& node, const CCBaseData& parentNode);
	static void nodeConcat(CCBaseData& target, CCBaseData& source);
	static void matrixToNode(const CCAffineTransform& _matrix, CCBaseData& _node);
	static void transformFromParent(CCBaseData& node, const CCBaseData& parentNode);
	static void nodeSub(CCBaseData& target, CCBaseData& source);
	static void transformToParent(CCBaseData& node, const CCBaseData& parentNode);
	CCTransformHelp();
};
class CCTMXLayerInfo : public CCObject {
	static CCTMXLayerInfo* create();
	void setOffsetY(float var);
	void setOffsetX(float var);
	void setTiles(int* var);
	int* getTiles();
	void setLayerWidth(int var);
	string getName();
	~CCTMXLayerInfo();
	void setAlpha(int var);
	int getLayerHeight();
	void setProperties(const CCDictionary& var);
	void setName(string var);
	float getOffsetY();
	float getOffsetX();
	string getProperty(const string& key);
	void addProperty(const string& key, const string& value);
	int getLayerWidth();
	void setLayerHeight(int var);
	CCDictionary& getProperties();
	bool isVisible();
	int getAlpha();
	void markVisible();
	void setVisible(bool var);
	void clearVisible();
};
class CCReuseGrid : public CCActionInstant {
	static CCReuseGrid* create(int times);
	void startWithTarget(CCNode* pTarget);
	bool initWithTimes(int times);
};
class ListView : public ScrollView {
	static ListView* create();
	static CCObject* createInstance();
	void setGravity(ListViewGravity gravity);
	void removeLastItem();
	string getDescription();
	float getItemsMargin();
	unsigned int getIndex(Widget* item);
	void pushBackCustomItem(Widget* item);
	void setDirection(SCROLLVIEW_DIR dir);
	void insertDefaultItem(int index);
	~ListView();
	void removeAllItems();
	CCArray* getItems();
	int getCurSelectedIndex();
	void sortAllChildren();
	void setItemsMargin(float margin);
	Widget* getItem(unsigned int index);
	void removeItem(int index);
	Widget* pushBackDefaultItem();
	void refreshView();
	void setItemModel(Widget* model);
	void requestRefreshView();
	void insertCustomItem(Widget* item, int index);
};
class CCSPXFileData : public CCAFCFileData {
	int m_tileCount;
	int m_frameCount;
	int m_actionCount;
	static CCSPXFileData* create();
	CCSPXAction* getActionAt(int index);
	CCSPXFrame* getFrameAt(int index);
	~CCSPXFileData();
};
class PositionFrame : public Frame {
	static PositionFrame* create();
	void onEnter(Frame* nextFrame);
	Frame* clone();
	float getX();
	float getY();
	void apply(float percent);
	void setPosition(const CCPoint& position);
	void setX(float x);
	void setY(float y);
	CCPoint getPosition();
};
class CCFlipX3D : public CCGrid3DAction {
	static CCFlipX3D* create(float duration);
	bool initWithSize(const CCSize& gridSize, float duration);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration);
	void update(float time);
};
class CCShine : public CCActionInterval {
	static CCShine* create(float duration, ccColor4B color1, ccColor4B color2, ccColor4B color3, ccVertex3F gradientPositions);
	void startWithTarget(CCNode* pTarget);
	const ccVertex3F& getGradientPositions();
	CCObject* copyWithZone(CCZone* pZone);
	void setColor1(const ccColor4B& var);
	bool initWithColors(float duration, ccColor4B color1, ccColor4B color2, ccColor4B color3, ccVertex3F gradientPositions);
	void stop();
	void update(float time);
	~CCShine();
	void setGradientPositions(const ccVertex3F& var);
	const ccColor4B& getColor2();
	const ccColor4B& getColor3();
	const ccColor4B& getColor1();
	void setColor2(const ccColor4B& var);
	void setColor3(const ccColor4B& var);
	CCActionInterval* reverse();
};
class CCStatement : public CCObject {
	void reset();
	const string& getQuery();
	~CCStatement();
	void setQuery(const string& var);
	void close();
};
class CCTableViewDelegate : public CCScrollViewDelegate {
	void tableCellTouched(CCTableView* table, CCTableViewCell* cell);
	void tableCellWillRecycle(CCTableView* table, CCTableViewCell* cell);
	void tableCellHighlight(CCTableView* table, CCTableViewCell* cell);
	void tableCellUnhighlight(CCTableView* table, CCTableViewCell* cell);
};
class CCControlPotentiometer : public CCControl {
	float m_fValue;
	float m_fMinimumValue;
	float m_fMaximumValue;
	static CCControlPotentiometer* create(const char* backgroundFile, const char* progressFile, const char* thumbFile);
	void setPreviousLocation(CCPoint var);
	void setProgressTimer(CCProgressTimer* var);
	void potentiometerMoved(CCPoint location);
	void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	float getMinimumValue();
	void setThumbSprite(CCSprite* var);
	~CCControlPotentiometer();
	bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	CCPoint getPreviousLocation();
	void setEnabled(bool enabled);
	void setValue(float value);
	void setMaximumValue(float maximumValue);
	void setMinimumValue(float minimumValue);
	void potentiometerEnded(CCPoint location);
	float distanceBetweenPointAndPoint(CCPoint point1, CCPoint point2);
	CCProgressTimer* getProgressTimer();
	float getMaximumValue();
	float angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(CCPoint beginLineA, CCPoint endLineA, CCPoint beginLineB, CCPoint endLineB);
	bool isTouchInside(CCTouch* touch);
	float getValue();
	void potentiometerBegan(CCPoint location);
	CCSprite* getThumbSprite();
	bool initWithTrackSprite_ProgressTimer_ThumbSprite(CCSprite* trackSprite, CCProgressTimer* progressTimer, CCSprite* thumbSprite);
};
class CCEaseQuinticActionIn : public CCActionEase {
	static CCEaseQuinticActionIn* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class ActionTimelineCache : public CCObject {
	static void destroyInstance();
	static ActionTimelineCache* getInstance();
	ActionTimeline* createAction(const string& fileName);
	~ActionTimelineCache();
	void purge();
	void init();
	ActionTimeline* loadAnimationActionWithContent(const string& fileName, const string& content);
	ActionTimeline* loadAnimationActionWithFile(const string& fileName);
	void removeAction(const string& fileName);
};
class CCBezierBy : public CCActionInterval {
	static CCBezierBy* create(float t, const ccBezierConfig& c);
	void startWithTarget(CCNode* pTarget);
	CCActionInterval* reverse();
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float t, const ccBezierConfig& c);
	void update(float time);
};
class CCEaseSineInOut : public CCActionEase {
	static CCEaseSineInOut* create(CCActionInterval* pAction);
	CCActionInterval* reverse();
	void update(float time);
	CCObject* copyWithZone(CCZone* pZone);
};
class CCUDPSocketHub : public CCObject {
	void markRawPolicy();
	void disconnect(int tag);
	CCUDPSocket* createSocket(const string& hostname, int port, int tag, int blockSec);
	~CCUDPSocketHub();
	void setSockets(const CCArray& var);
	void setRawPolicy(bool var);
	CCUDPSocket* getSocket(int tag);
	void sendPacket(int tag, CCPacket* packet);
	const CCArray& getSockets();
	bool isRawPolicy();
	void stopAll();
	void clearRawPolicy();
};
class CCScrollBar : public CCLayer, public CCScrollViewDelegate {
	static CCScrollBar* create @ createpCpC(CCScale9Sprite* track, CCSprite* thumb);
	static CCScrollBar* create @ createpCpC(CCScale9Sprite* track, CCScale9Sprite* thumb);
	bool initWithTrackAndFixedThumb(CCScale9Sprite* track, CCSprite* thumb);
	bool isHorizontal();
	void setTrack(CCScale9Sprite* var);
	void markHorizontal();
	void setAutoFade(bool autoFade, bool initFadeOut);
	CCScale9Sprite* getTrack();
	void scrollViewDidZoom(CCScrollView* view);
	void update(float delta);
	~CCScrollBar();
	void setThumb(CCScale9Sprite* var);
	void attachToScrollView(ScrollView* scrollView, ccInsets insets, bool horizontal);
	void setFixedThumb(CCSprite* var);
	void clearHorizontal();
	void scrollViewDidScroll(CCScrollView* view);
	CCSprite* getFixedThumb();
	CCScale9Sprite* getThumb();
	void setHorizontal(bool var);
	void attachToCCScrollView(CCScrollView* scrollView, ccInsets insets, bool horizontal);
	bool initWithTrackAndThumb(CCScale9Sprite* track, CCScale9Sprite* thumb);
};
class CCEaseCircleActionIn : public CCActionEase {
	static CCEaseCircleActionIn* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCControlSwitch : public CCControl {
	static CCControlSwitch* create @ createpCpCpCpCpCpC(CCSprite* maskSprite, CCSprite* onSprite, CCSprite* offSprite, CCSprite* thumbSprite, CCLabelTTF* onLabel, CCLabelTTF* offLabel);
	static CCControlSwitch* create @ createpCpCpCpC(CCSprite* maskSprite, CCSprite* onSprite, CCSprite* offSprite, CCSprite* thumbSprite);
	void setEnabled(bool enabled);
	void setOn @ setOnb(bool isOn);
	void setOn @ setOnbb(bool isOn, bool animated);
	bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	bool isOn();
	void ccTouchCancelled(CCTouch* pTouch, CCEvent* pEvent);
	void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	bool initWithMaskSprite @ initWithMaskSpritepCpCpCpCpCpC(CCSprite* maskSprite, CCSprite* onSprite, CCSprite* offSprite, CCSprite* thumbSprite, CCLabelTTF* onLabel, CCLabelTTF* offLabel);
	bool initWithMaskSprite @ initWithMaskSpritepCpCpCpC(CCSprite* maskSprite, CCSprite* onSprite, CCSprite* offSprite, CCSprite* thumbSprite);
	void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	bool hasMoved();
	~CCControlSwitch();
	CCPoint locationFromTouch(CCTouch* touch);
};
class CCScale9Sprite : public CCNodeRGBA {
	static CCScale9Sprite* create @ createpccC(const char* file, CCRect rect);
	static CCScale9Sprite* create @ createpccCC(const char* file, CCRect rect, CCRect capInsets);
	static CCScale9Sprite* create @ createCpcc(CCRect capInsets, const char* file);
	static CCScale9Sprite* create @ createpcc(const char* file);
	static CCScale9Sprite* create @ create();
	static CCScale9Sprite* createWithSpriteFrameName @ createWithSpriteFrameNamepcc(const char* spriteFrameName);
	static CCScale9Sprite* createWithSpriteFrameName @ createWithSpriteFrameNamepccC(const char* spriteFrameName, CCRect capInsets);
	static CCScale9Sprite* createWithSpriteFrame @ createWithSpriteFramepC(CCSpriteFrame* spriteFrame);
	static CCScale9Sprite* createWithSpriteFrame @ createWithSpriteFramepCC(CCSpriteFrame* spriteFrame, CCRect capInsets);
	CCRect getCapInsets();
	void setOpacityModifyRGB(bool bValue);
	void setInsetTop(float var);
	bool updateWithBatchNode(CCSpriteBatchNode* batchnode, CCRect rect, bool rotated, CCRect capInsets);
	void setInsetBottom(float var);
	bool isOpacityModifyRGB();
	void visit();
	bool initWithSpriteFrameName @ initWithSpriteFrameNamepcc(const char* spriteFrameName);
	bool initWithSpriteFrameName @ initWithSpriteFrameNamepccC(const char* spriteFrameName, CCRect capInsets);
	~CCScale9Sprite();
	void updateDisplayedOpacity(unsigned char parentOpacity);
	bool init();
	void setPreferredSize(CCSize var);
	unsigned char getOpacity();
	void setSpriteFrame(CCSpriteFrame* spriteFrame);
	const ccColor3B& getColor();
	bool initWithBatchNode @ initWithBatchNodepCCC(CCSpriteBatchNode* batchnode, CCRect rect, CCRect capInsets);
	bool initWithBatchNode @ initWithBatchNodepCCbC(CCSpriteBatchNode* batchnode, CCRect rect, bool rotated, CCRect capInsets);
	float getInsetBottom();
	CCScale9Sprite* resizableSpriteWithCapInsets(CCRect capInsets);
	void setOpacity(unsigned char opacity);
	void setContentSize(const CCSize& size);
	float getInsetRight();
	CCSize getOriginalSize();
	bool initWithFile @ initWithFilepccC(const char* file, CCRect rect);
	bool initWithFile @ initWithFilepccCC(const char* file, CCRect rect, CCRect capInsets);
	bool initWithFile @ initWithFileCpcc(CCRect capInsets, const char* file);
	bool initWithFile @ initWithFilepcc(const char* file);
	void setColor(const ccColor3B& color);
	float getInsetTop();
	void setInsetLeft(float var);
	bool initWithSpriteFrame @ initWithSpriteFramepC(CCSpriteFrame* spriteFrame);
	bool initWithSpriteFrame @ initWithSpriteFramepCC(CCSpriteFrame* spriteFrame, CCRect capInsets);
	CCSize getPreferredSize();
	void setCapInsets(CCRect var);
	float getInsetLeft();
	void updateDisplayedColor(const ccColor3B& parentColor);
	void setInsetRight(float var);
};
class CCLiquid : public CCGrid3DAction {
	static CCLiquid* create(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);
	void update(float time);
	float getAmplitudeRate();
	void setAmplitude(float fAmplitude);
	float getAmplitude();
	void setAmplitudeRate(float fAmplitudeRate);
};
class CCEaseBounceInOut : public CCEaseBounce {
	static CCEaseBounceInOut* create(CCActionInterval* pAction);
	CCActionInterval* reverse();
	void update(float time);
	CCObject* copyWithZone(CCZone* pZone);
};
class CCActionTween : public CCActionInterval {
	string m_strKey;
	float m_fFrom;
	float m_fTo;
	float m_fDelta;
	static CCActionTween* create(float aDuration, const char* key, float from, float to);
	void startWithTarget(CCNode* pTarget);
	void update(float dt);
	bool initWithDuration(float aDuration, const char* key, float from, float to);
	CCActionInterval* reverse();
};
class CCAnimation : public CCObject {
	static CCAnimation* create @ createpCfui(CCArray* arrayOfAnimationFrameNames, float delayPerUnit, unsigned int loops);
	static CCAnimation* create @ create();
	static CCAnimation* create @ createpCf(CCArray* arrayOfAnimationFrameNames, float delayPerUnit);
	static CCAnimation* createWithSpriteFrames(CCArray* arrayOfSpriteFrameNames, float delay);
	void addSpriteFrameWithFileName(const char* pszFileName);
	void setFrames(CCArray* var);
	CCObject* copyWithZone(CCZone* pZone);
	CCArray* getFrames();
	void addSpriteFrame(CCSpriteFrame* pFrame);
	void setDelayPerUnit(float var);
	bool initWithAnimationFrames(CCArray* arrayOfAnimationFrames, float delayPerUnit, unsigned int loops);
	~CCAnimation();
	bool init();
	bool initWithSpriteFrames(CCArray* pFrames, float delay);
	unsigned int getLoops();
	void setLoops(unsigned int var);
	void setRestoreOriginalFrame(bool var);
	float getTotalDelayUnits();
	float getDelayPerUnit();
	bool getRestoreOriginalFrame();
	float getDuration();
	void addSpriteFrameWithTexture(CCTexture2D* pobTexture, const CCRect& rect);
};
class CCApplication : public CCApplicationProtocol {
	static CCApplication* sharedApplication();
	int run();
	ccLanguageType getCurrentLanguage();
	TargetPlatform getTargetPlatform();
	~CCApplication();
	void setAnimationInterval(double interval);
};
class CCTextureData : public CCObject {
	float height;
	float width;
	float pivotX;
	float pivotY;
	string name;
	CCArray contourDataList;
	static CCTextureData* create();
	CCContourData* getContourData(int index);
	void addContourData(CCContourData* contourData);
	bool init();
	~CCTextureData();
};
class CCTCPSocketHub : public CCObject {
	void markRawPolicy();
	void disconnect(int tag);
	CCTCPSocket* createSocket(const string& hostname, int port, int tag, int blockSec, bool keepAlive);
	~CCTCPSocketHub();
	void setSockets(const CCArray& var);
	void setRawPolicy(bool var);
	CCTCPSocket* getSocket(int tag);
	void sendPacket(int tag, CCPacket* packet);
	const CCArray& getSockets();
	bool isRawPolicy();
	void stopAll();
	void clearRawPolicy();
};
class CCEaseBounce : public CCActionEase {
	static CCEaseBounce* create(CCActionInterval* pAction);
	float bounceTime(float time);
	CCObject* copyWithZone(CCZone* pZone);
	CCActionInterval* reverse();
};
class LoadingBar : public Widget, public CCMeasurableProtocol {
	static LoadingBar* create();
	static CCObject* createInstance();
	void setPercent(int percent);
	CCNode* getVirtualRenderer();
	void ignoreContentAdaptWithSize(bool ignore);
	void loadTexture(const char* texture, TextureResType texType);
	void setDirection(LoadingBarType dir);
	float getPercentage();
	string getDescription();
	void setScale9Enabled(bool enabled);
	~LoadingBar();
	void setCapInsets(const CCRect& capInsets);
	int getDirection();
	void setPercentage(float p);
	const CCRect& getCapInsets();
	const CCSize& getContentSize();
	bool isScale9Enabled();
	int getPercent();
};
class CCParticleSpiral : public CCParticleSystemQuad {
	static CCParticleSpiral* create();
	static CCParticleSpiral* createWithTotalParticles(unsigned int numberOfParticles);
	bool init();
	~CCParticleSpiral();
	bool initWithTotalParticles(unsigned int numberOfParticles);
};
class CCPinyinUtils {
	static string chs2Pinyin(const string& s);
};
class CCHttpRequest : public CCObject {
	static CCHttpRequest* create();
	const string& getUrl();
	void setUserData(void* var);
	void* getUserData();
	CCData* getRequestData();
	void clearCancel();
	void setCancel(bool var);
	void setUrl(const string& var);
	HttpMethod getMethod();
	~CCHttpRequest();
	void setMethod(HttpMethod var);
	bool isCancel();
	void setRequestData(CCData* var);
	void setTag(const int& var);
	const int& getTag();
	void markCancel();
	typedef enum {
		kHttpGet,
		kHttpPost,
		kHttpPut,
		kHttpDelete,
		kHttpUnknown
	} HttpMethod;
};
class CCTargetedTouchHandler : public CCTouchHandler {
	static CCTargetedTouchHandler* handlerWithDelegate(CCTouchDelegate* pDelegate, int nPriority, bool bSwallow);
	bool isSwallowsTouches();
	CCSet* getClaimedTouches();
	void setSwallowsTouches(bool bSwallowsTouches);
	bool initWithDelegate(CCTouchDelegate* pDelegate, int nPriority, bool bSwallow);
	~CCTargetedTouchHandler();
};
class LabelBMFont : public Widget {
	static LabelBMFont* create();
	static CCObject* createInstance();
	void setAnchorPoint(const CCPoint& pt);
	CCNode* getVirtualRenderer();
	const char* getStringValue();
	void setText(const char* value);
	string getDescription();
	~LabelBMFont();
	const CCSize& getContentSize();
	void setFntFile(const char* fileName);
};
class CCBool : public CCObject {
	static CCBool* create(bool v);
	bool getValue();
	void acceptVisitor(CCDataVisitor& visitor);
};
class CCEaseElasticInOut : public CCEaseElastic {
	static CCEaseElasticInOut* create @ createpC(CCActionInterval* pAction);
	static CCEaseElasticInOut* create @ createpCf(CCActionInterval* pAction, float fPeriod);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCCatmullRomTo : public CCCardinalSplineTo {
	static CCCatmullRomTo* create(float dt, CCPointArray* points);
	bool initWithDuration(float dt, CCPointArray* points);
};
class CCLabelTTFLinkStateSynchronizer : public CCObject, public CCMenuItemColorStateListener {
	void onMenuItemColorFocused(CCMenuItemColor* item);
	void onMenuItemColorDeselected(CCMenuItemColor* item);
	~CCLabelTTFLinkStateSynchronizer();
	void onMenuItemColorSelected(CCMenuItemColor* item);
	void onMenuItemColorDisabled(CCMenuItemColor* item);
	void onMenuItemColorUnfocused(CCMenuItemColor* item);
	void onMenuItemColorEnabled(CCMenuItemColor* item);
};
class CCBezierTo : public CCBezierBy {
	static CCBezierTo* create(float t, const ccBezierConfig& c);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float t, const ccBezierConfig& c);
};
class CCDeccelAmplitude : public CCActionInterval {
	static CCDeccelAmplitude* create(CCAction* pAction, float duration);
	void startWithTarget(CCNode* pTarget);
	CCActionInterval* reverse();
	void update(float time);
	float getRate();
	void setRate(float fRate);
	bool initWithAction(CCAction* pAction, float duration);
	~CCDeccelAmplitude();
};
class CCEaseBounceOut : public CCEaseBounce {
	static CCEaseBounceOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCJumpTo : public CCJumpBy {
	static CCJumpTo* create(float duration, const CCPoint& position, float height, int jumps, bool autoHeadOn, float initAngle);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
};
class Button : public Widget {
	static Button* create();
	static CCObject* createInstance();
	void setAnchorPoint(const CCPoint& pt);
	CCNode* getVirtualRenderer();
	const char* getTitleText();
	void setTitleFontSize(float size);
	string getDescription();
	void setScale9Enabled(bool able);
	void setTitleColor(const ccColor3B& color);
	void ignoreContentAdaptWithSize(bool ignore);
	void setCapInsetsDisabledRenderer(const CCRect& capInsets);
	const CCRect& getCapInsetPressedRenderer();
	const ccColor3B& getTitleColor();
	void loadTextureDisabled(const char* disabled, TextureResType texType);
	~Button();
	const CCSize& getContentSize();
	void setTitleText(const string& text);
	const CCRect& getCapInsetNormalRenderer();
	void setCapInsetsNormalRenderer(const CCRect& capInsets);
	void loadTexturePressed(const char* selected, TextureResType texType);
	void setTitleFontName(const char* fontName);
	void loadTextures(const char* normal, const char* selected, const char* disabled, TextureResType texType);
	bool isScale9Enabled();
	const CCRect& getCapInsetDisabledRenderer();
	void loadTextureNormal(const char* normal, TextureResType texType);
	void setCapInsetsPressedRenderer(const CCRect& capInsets);
	float getTitleFontSize();
	const char* getTitleFontName();
	void setCapInsets(const CCRect& capInsets);
	void setPressedActionEnabled(bool enabled);
};
class CCWavesTiles3D : public CCTiledGrid3DAction {
	static CCWavesTiles3D* create(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);
	void update(float time);
	float getAmplitudeRate();
	void setAmplitude(float fAmplitude);
	float getAmplitude();
	void setAmplitudeRate(float fAmplitudeRate);
};
class GUIReader : public CCObject {
	static void purge();
	static GUIReader* shareReader();
	void setFilePath(const string& strFilePath);
	CCSize getFileDesignSize(const char* fileName);
	void storeFileDesignSize(const char* fileName, const CCSize& size);
	~GUIReader();
	Widget* widgetFromJsonFile(const char* fileName);
	const string& getFilePath();
	Widget* widgetFromBinaryFile(const char* fileName);
	int getVersionInteger(const char* str);
};
class CCSPXManager : public CCObject {
	static CCSPXManager* getInstance();
	CCSPXFileData* load(const char* spxPath);
	void releaseAllAnimationFileData();
	CCAFCAnimation* getAnimationData(CCSPXFileData* spx, int animIndex, CCAFCClipMapping* mapping);
	~CCSPXManager();
};
class CCTextFieldTTF : public CCLabelTTF, public CCIMEDelegate {
	static CCTextFieldTTF* textFieldWithPlaceHolder @ textFieldWithPlaceHolderpccpccf(const char* placeholder, const char* fontName, float fontSize);
	static CCTextFieldTTF* textFieldWithPlaceHolder @ textFieldWithPlaceHolderpccrcCCpccf(const char* placeholder, const CCSize& dimensions, CCTextAlignment alignment, const char* fontName, float fontSize);
	int getCharCount();
	CCTextFieldDelegate* getDelegate();
	const char* getPlaceHolder();
	const char* getString();
	void setSecureTextEntry(bool value);
	const ccColor3B& getColorSpaceHolder();
	bool initWithPlaceHolder @ initWithPlaceHolderpccpccf(const char* placeholder, const char* fontName, float fontSize);
	bool initWithPlaceHolder @ initWithPlaceHolderpccrcCCpccf(const char* placeholder, const CCSize& dimensions, CCTextAlignment alignment, const char* fontName, float fontSize);
	~CCTextFieldTTF();
	void setColorSpaceHolder(const ccColor3B& color);
	bool detachWithIME();
	void setDelegate(CCTextFieldDelegate* var);
	void setPlaceHolder(const char* text);
	bool isSecureTextEntry();
	void setString(const char* text);
	bool attachWithIME();
};
class CCCount : public CCActionInterval {
	static CCCount* create(float duration, int from, int to, const string& pattern);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float d, int from, int to, const string& pattern);
	void update(float time);
	~CCCount();
	CCActionInterval* reverse();
};
class CCTransitionJumpZoom : public CCTransitionScene {
	static CCTransitionJumpZoom* create(float t, CCScene* scene);
	~CCTransitionJumpZoom();
	void onEnter();
};
class CCTouch : public CCObject {
	CCPoint getPreviousLocationInView();
	CCPoint getLocation();
	CCPoint getDelta();
	CCPoint getStartLocationInView();
	CCPoint getStartLocation();
	int getID();
	void setTouchInfo(int id, float x, float y);
	CCPoint getLocationInView();
	CCPoint getPreviousLocation();
};
class PageView : public Layout, public UIScrollInterface {
	static PageView* create();
	static CCObject* createInstance();
	void onTouchEnded(CCTouch* touch, CCEvent* unusedEvent);
	int getCurPageIndex();
	void onTouchMoved(CCTouch* touch, CCEvent* unusedEvent);
	string getDescription();
	Widget* getCurPage();
	void recyclePage(Widget* page);
	PageViewDataSource* getDataSource();
	void setCurPage(Widget* var);
	void onEnter();
	~PageView();
	Widget* dequeuePageItem(const string& itemId);
	void reloadData @ reloadData();
	void reloadData @ reloadDatai(int wantedPageIndex);
	Widget* getRightChild();
	LayoutType getLayoutType();
	void setRightChild(Widget* var);
	void enqueuePageItem(Widget* item, const string& itemId);
	Widget* getLeftChild();
	void update(float dt);
	void onTouchCancelled(CCTouch* touch, CCEvent* unusedEvent);
	void scrollToPage(int idx, bool animation);
	bool onTouchBegan(CCTouch* touch, CCEvent* unusedEvent);
	void setDataSource(PageViewDataSource* var);
	void setLeftChild(Widget* var);
	void setLayoutType(LayoutType type);
};
class CCImage : public CCObject {
	int getDataLen();
	bool isPremultipliedAlpha();
	int getBitsPerComponent();
	unsigned short getWidth();
	bool initWithImageFileThreadSafe(const char* fullpath, EImageFormat imageType);
	bool initWithString(const char* pText, int nWidth, int nHeight, ETextAlign eAlignMask, const char* pFontName, int nSize);
	unsigned short getHeight();
	bool initWithImageFile(const char* strPath, EImageFormat imageType);
	~CCImage();
	int getRealLength();
	bool isNeedTime();
	unsigned char* getData();
	const CCPoint& getShadowStrokePadding();
	bool saveToFile(const char* pszFilePath, bool bIsToRGB);
	bool initWithImageData(void* pData, int nDataLen, EImageFormat eFmt, int nWidth, int nHeight, int nBitsPerComponent);
	void setNeedTime(bool var);
	bool hasAlpha();
	void setRealLength(int var);
	void clearNeedTime();
	void markNeedTime();
	typedef enum {
		kAlignCenter,
		kAlignTop,
		kAlignTopRight,
		kAlignRight,
		kAlignBottomRight,
		kAlignBottom,
		kAlignBottomLeft,
		kAlignLeft,
		kAlignTopLeft
	} ETextAlign;
};
class CCResourceLoader : public CCObject {
	static void unloadArmatures(string plistPattern, string texPattern, int start, int end, string config);
	static void unloadSpriteFrames(const string& plistPattern, const string& texPattern, int start, int end);
	static void abortAll();
	static void unloadImages @ unloadImagesrcsii(const string& texPattern, int start, int end);
	static void unloadImages @ unloadImagesrcs(const string& tex);
	float getDelay();
	void addAndroidStringTask(const string& lan, const string& path, bool merge);
	void addBMFontTask(const string& fntFile, float idle);
	void run();
	void addCustomTask(CCCallFunc* func);
	void addArmatureTask(string config, float idle);
	void addZwoptexAnimTask @ addZwoptexAnimTaskrcsfrcsiiiibf(const string& name, float unitDelay, const string& pattern, int startIndex, int endIndex, int startIndex2, int endIndex2, bool restoreOriginalFrame, float idle);
	void addZwoptexAnimTask @ addZwoptexAnimTaskrcsfrcsiibf(const string& name, float unitDelay, const string& pattern, int startIndex, int endIndex, bool restoreOriginalFrame, float idle);
	void addZwoptexAnimTask @ addZwoptexAnimTaskrcsrcsiircsbf(const string& name, const string& pattern, int startIndex, int endIndex, const string& delayString, bool restoreOriginalFrame, float idle);
	void addZwoptexAnimTask @ addZwoptexAnimTaskrcsrcsrcsfbf(const string& name, const string& pattern, const string& indicesString, float delay, bool restoreOriginalFrame, float idle);
	void addZwoptexAnimTask @ addZwoptexAnimTaskrcsrcsrcsrcsbf(const string& name, const string& pattern, const string& indicesString, const string& delayString, bool restoreOriginalFrame, float idle);
	~CCResourceLoader();
	void addZwoptexTask @ addZwoptexTaskrcsiif(const string& pattern, int start, int end, float idle);
	void addZwoptexTask @ addZwoptexTaskrcsf(const string& name, float idle);
	void runInBlockMode();
	void abort();
	void setDelay(float var);
	void addCDMusicTask(const string& name, float idle);
	void addCDEffectTask(const string& name, float idle);
	void addLoadTask(LoadTask* t);
	void addImageTask(const string& name, float idle);
	struct LoadTask {
		float idle;
		void load();
		~LoadTask();
		LoadTask();
	};
};
class CCEaseQuarticActionInOut : public CCActionEase {
	static CCEaseQuarticActionInOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCGLProgram : public CCObject {
	bool initWithVertexShaderFilename(const char* vShaderFilename, const char* fShaderFilename);
	const char* fragmentShaderLog();
	void addAttribute(const char* attributeName, unsigned int index);
	void setUniformLocationWith3fv(int location, float* floats, unsigned int numberOfArrays);
	const char* vertexShaderLog();
	void setUniformLocationWith2fv(int location, float* floats, unsigned int numberOfArrays);
	void setUniformLocationWithMatrix4fv(int location, float* matrixArray, unsigned int numberOfMatrices);
	int getUniformLocationForName(const char* name);
	void use();
	void setUniformLocationWith1i(int location, int i1);
	void setUniformLocationWith1f(int location, float f1);
	unsigned int getProgram();
	~CCGLProgram();
	void setUniformLocationWith3f(int location, float f1, float f2, float f3);
	void setUniformsForBuiltins();
	void setUniformLocationWith3i(int location, int i1, int i2, int i3);
	void setUniformLocationWith3iv(int location, int* ints, unsigned int numberOfArrays);
	void updateUniforms();
	void setUniformLocationWith4iv(int location, int* ints, unsigned int numberOfArrays);
	bool link();
	void setUniformLocationWith2iv(int location, int* ints, unsigned int numberOfArrays);
	void reset();
	void setUniformLocationWith4fv(int location, float* floats, unsigned int numberOfArrays);
	bool initWithVertexShaderByteArray(const char* vShaderByteArray, const char* fShaderByteArray);
	const char* programLog();
	void setUniformLocationWith2f(int location, float f1, float f2);
	void setUniformLocationWith4f(int location, float f1, float f2, float f3, float f4);
	void setUniformLocationWith4i(int location, int i1, int i2, int i3, int i4);
	void setUniformLocationWith2i(int location, int i1, int i2);
};
class CCActionManager : public CCObject {
	CCAction* getActionByTag(unsigned int tag, CCObject* pTarget);
	void addAction(CCAction* pAction, CCNode* pTarget, bool paused);
	void removeAllActions();
	void removeActionByTag(unsigned int tag, CCObject* pTarget);
	void resumeTarget(CCObject* pTarget);
	~CCActionManager();
	void pauseTarget(CCObject* pTarget);
	void removeAllActionsFromTarget(CCObject* pTarget);
	void resumeTargets(CCSet* targetsToResume);
	void removeAction(CCAction* pAction);
	unsigned int numberOfRunningActionsInTarget(CCObject* pTarget);
	void registerWatcher(CCActionWatcher* w);
	CCSet* pauseAllRunningActions();
};
class CCAFCClip : public CCObject {
	static CCAFCClip* create();
	int getIndex();
	CCAFCClipType getType();
	void setIndex(int i);
	~CCAFCClip();
	CCAFCClipData& getData();
	void setType(CCAFCClipType type);
};
class CCAuroraManager : public CCObject {
	static CCAuroraManager* getInstance();
	CCAuroraFileData* load(const char* asPath);
	void releaseAllAnimationFileData();
	CCAFCAnimation* getAnimationData(CCAuroraFileData* afd, int animIndex, CCAFCClipMapping* mapping);
	~CCAuroraManager();
};
class CCBoneData : public CCBaseData {
	string name;
	string parentName;
	CCArray displayDataList;
	CCAffineTransform boneDataTransform;
	static CCBoneData* create();
	CCDisplayData* getDisplayData(int index);
	bool init();
	~CCBoneData();
	void addDisplayData(CCDisplayData* displayData);
};
class CCBase64 {
	static string encode(const void* data, int len);
	static const char* decode(const string& data, int* outLen);
	static const char* decodeAsCString(const string& data, int* outLen);
};
class CCReverseTime : public CCActionInterval {
	static CCReverseTime* create(CCFiniteTimeAction* pAction);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	void stop();
	void update(float time);
	~CCReverseTime();
	bool initWithAction(CCFiniteTimeAction* pAction);
	CCActionInterval* reverse();
};
class CCFrameData : public CCBaseData {
	int frameID;
	int duration;
	CCTweenType tweenEasing;
	int easingParamNumber;
	bool isTween;
	int displayIndex;
	ccBlendFunc blendFunc;
	string strEvent;
	string strMovement;
	string strSound;
	string strSoundEffect;
	static CCFrameData* create();
	void copy(const CCBaseData* node);
	~CCFrameData();
};
class CCDataVisitor {
	void visitObject(const CCObject* p);
	void visit @ visitpcC(const CCInteger* p);
	void visit @ visitpcC(const CCBool* p);
	void visit @ visitpcC(const CCFloat* p);
	void visit @ visitpcC(const CCDouble* p);
	void visit @ visitpcC(const CCString* p);
	void visit @ visitpcC(const CCArray* p);
	void visit @ visitpcC(const CCDictionary* p);
	void visit @ visitpcC(const CCSet* p);
	~CCDataVisitor();
};
class CCMenuItemColorStateListener {
	void onMenuItemColorFocused(CCMenuItemColor* item);
	void onMenuItemColorDeselected(CCMenuItemColor* item);
	void onMenuItemColorDisabled(CCMenuItemColor* item);
	void onMenuItemColorSelected(CCMenuItemColor* item);
	void onMenuItemColorUnfocused(CCMenuItemColor* item);
	void onMenuItemColorEnabled(CCMenuItemColor* item);
};
class CCTargetedAction : public CCActionInterval {
	static CCTargetedAction* create(CCNode* pTarget, CCFiniteTimeAction* pAction);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	void setForcedTarget(CCNode* var);
	bool initWithTarget(CCNode* pTarget, CCFiniteTimeAction* pAction);
	void stop();
	void update(float time);
	~CCTargetedAction();
	CCNode* getForcedTarget();
};
class CCScene : public CCNode {
	static CCScene* create();
	bool init();
	~CCScene();
};
class RotationFrame : public Frame {
	static RotationFrame* create();
	void onEnter(Frame* nextFrame);
	Frame* clone();
	float getRotation();
	void setRotation(float rotation);
	void apply(float percent);
};
class CCNotificationObserver : public CCObject {
	void performSelector(CCObject* obj);
	char* getName();
	CCObject* getTarget();
	~CCNotificationObserver();
	CCObject* getObject();
	int getHandler();
	void setHandler(int var);
};
class CCApplicationProtocol {
	void applicationDidEnterBackground();
	void applicationWillEnterForeground();
	bool applicationDidFinishLaunching();
	ccLanguageType getCurrentLanguage();
	TargetPlatform getTargetPlatform();
	~CCApplicationProtocol();
	void setAnimationInterval(double interval);
};
class CCFiniteTimeAction : public CCAction {
	void setDuration(float duration);
	~CCFiniteTimeAction();
	CCFiniteTimeAction* reverse();
	float getDuration();
};
class CCShakyTiles3D : public CCTiledGrid3DAction {
	static CCShakyTiles3D* create(float duration, const CCSize& gridSize, int nRange, bool bShakeZ);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCSize& gridSize, int nRange, bool bShakeZ);
	void update(float time);
};
class CCJumpBy : public CCActionInterval {
	static CCJumpBy* create(float duration, const CCPoint& position, float height, unsigned int jumps, bool autoHeadOn, float initAngle);
	void startWithTarget(CCNode* pTarget);
	CCActionInterval* reverse();
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCPoint& position, float height, unsigned int jumps, bool autoHeadOn, float initAngle);
	void update(float time);
};
class CCParticleDisplayData : public CCDisplayData {
	static CCParticleDisplayData* create();
	~CCParticleDisplayData();
};
class CCTransitionProgressRadialCCW : public CCTransitionProgress {
	static CCTransitionProgressRadialCCW* create(float t, CCScene* scene);
};
class CCClipIn : public CCActionInterval {
	static CCClipIn* create(float duration, CCPoint v);
	void startWithTarget(CCNode* pTarget);
	CCActionInterval* reverse();
	bool initWithDuration(float d, const CCPoint& v);
	void setDirection(const CCPoint& var);
	void update(float time);
	~CCClipIn();
	const CCPoint& getDirection();
};
class CCTransitionProgress : public CCTransitionScene {
	static CCTransitionProgress* create(float t, CCScene* scene);
	void onEnter();
	void onExit();
};
class CCCatmullRomBy : public CCCardinalSplineBy {
	static CCCatmullRomBy* create(float dt, CCPointArray* points);
	bool initWithDuration(float dt, CCPointArray* points);
};
class CCTransitionFlipAngular : public CCTransitionSceneOriented {
	static CCTransitionFlipAngular* create @ createfpC(float t, CCScene* s);
	static CCTransitionFlipAngular* create @ createfpCt(float t, CCScene* s, tOrientation o);
	~CCTransitionFlipAngular();
	void onEnter();
};
class CCEaseQuinticActionOut : public CCActionEase {
	static CCEaseQuinticActionOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCTransitionFadeUp : public CCTransitionFadeTR {
	static CCTransitionFadeUp* create(float t, CCScene* scene);
	CCActionInterval* actionWithSize(const CCSize& size);
	~CCTransitionFadeUp();
};
class CCColliderFilter {
	~CCColliderFilter();
};
class CCTableView : public CCScrollView, public CCScrollViewDelegate {
	static CCTableView* create @ createpCCpC(CCTableViewDataSource* dataSource, CCSize size, CCNode* container);
	static CCTableView* create @ createpCC(CCTableViewDataSource* dataSource, CCSize size);
	bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	void scrollViewDidScroll(CCScrollView* view);
	void setColCount(unsigned int var);
	void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	CCTableViewDataSource* getDataSource();
	void updateCellAtIndex(unsigned int idx);
	bool initWithViewSize(CCSize size, CCNode* container);
	void removeCellAtIndex(unsigned int idx);
	~CCTableView();
	unsigned int getColCount();
	void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	void reloadData();
	CCTableViewCell* dequeueCell(const string& name);
	void setDelegate(CCTableViewDelegate* pDelegate);
	void scrollViewDidZoom(CCScrollView* view);
	void insertCellAtIndex(unsigned int idx);
	CCTableViewCell* cellAtIndex(unsigned int idx);
	CCTableViewDelegate* getDelegate();
	int getRealRows();
	void _updateContentSize();
	void unregisterAllScriptHandler();
	void ccTouchCancelled(CCTouch* pTouch, CCEvent* pEvent);
	void setDataSource(CCTableViewDataSource* source);
};
class CCTreeFadeIn : public CCFadeIn {
	static CCTreeFadeIn* create(float d);
	void excludeNode(CCNode* n, bool recursively);
	void update(float time);
	CCActionInterval* reverse();
};
class CCTransitionCrossFade : public CCTransitionScene {
	static CCTransitionCrossFade* create(float t, CCScene* scene);
	void draw();
	~CCTransitionCrossFade();
	void onEnter();
	void onExit();
};
class CCControlButton : public CCControl {
	bool m_doesAdjustBackgroundImage;
	static CCControlButton* create @ createspccf(string title, const char* fontName, float fontSize);
	static CCControlButton* create @ createpCpC(CCNode* label, CCScale9Sprite* backgroundSprite);
	static CCControlButton* create @ createpC(CCScale9Sprite* sprite);
	static CCControlButton* create @ create();
	void setTitleColorDispatchTable(CCDictionary* var);
	void setZoomOnTouchDown(bool var);
	void setSelected(bool enabled);
	void setTitleLabel(CCNode* var);
	bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	void setTitleTTFSizeForState(float size, unsigned int state);
	void setAdjustBackgroundImage(bool adjustBackgroundImage);
	void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	void setHighlighted(bool enabled);
	void setBackgroundSpriteDispatchTable(CCDictionary* var);
	void setTitleLabelForState(CCNode* label, unsigned int state);
	void setTitleForState(CCString* title, unsigned int state);
	CCDictionary* getTitleDispatchTable();
	void setLabelAnchorPoint(CCPoint var);
	void ccTouchCancelled(CCTouch* pTouch, CCEvent* pEvent);
	CCPoint getLabelAnchorPoint();
	bool initWithBackgroundSprite(CCScale9Sprite* sprite);
	float getTitleTTFSizeForState(unsigned int state);
	void setTitleDispatchTable(CCDictionary* var);
	bool isPushed();
	void setOpacity(unsigned char var);
	~CCControlButton();
	bool init();
	void setTitleTTFForState(const char* fntFile, unsigned int state);
	void setPreferredSize(CCSize var);
	int getHorizontalOrigin();
	void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	unsigned char getOpacity();
	const ccColor3B& getCurrentTitleColor();
	CCDictionary* getTitleColorDispatchTable();
	void setEnabled(bool enabled);
	CCScale9Sprite* getBackgroundSpriteForState(unsigned int state);
	const ccColor3B& getColor();
	void setMargins(int marginH, int marginV);
	void needsLayout();
	bool initWithTitleAndFontNameAndFontSize(string title, const char* fontName, float fontSize);
	void setTitleBMFontForState(const char* fntFile, unsigned int state);
	const char* getTitleTTFForState(unsigned int state);
	CCScale9Sprite* getBackgroundSprite();
	ccColor3B getTitleColorForState(unsigned int state);
	void setTitleColorForState(ccColor3B color, unsigned int state);
	bool doesAdjustBackgroundImage();
	void setBackgroundSpriteFrameForState(CCSpriteFrame* spriteFrame, unsigned int state);
	void setBackgroundSpriteForState(CCScale9Sprite* sprite, unsigned int state);
	void setColor(const ccColor3B& );
	CCDictionary* getTitleLabelDispatchTable();
	bool initWithLabelAndBackgroundSprite(CCNode* label, CCScale9Sprite* backgroundSprite);
	void setTitleLabelDispatchTable(CCDictionary* var);
	CCNode* getTitleLabel();
	CCSize getPreferredSize();
	int getVerticalMargin();
	CCDictionary* getBackgroundSpriteDispatchTable();
	CCNode* getTitleLabelForState(unsigned int state);
	CCString* getCurrentTitle();
	const char* getTitleBMFontForState(unsigned int state);
	void setBackgroundSprite(CCScale9Sprite* var);
	bool getZoomOnTouchDown();
	CCString* getTitleForState(unsigned int state);
};
class CCEaseElasticIn : public CCEaseElastic {
	static CCEaseElasticIn* create @ createpC(CCActionInterval* pAction);
	static CCEaseElasticIn* create @ createpCf(CCActionInterval* pAction, float fPeriod);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCActionCamera : public CCActionInterval {
	void startWithTarget(CCNode* pTarget);
	~CCActionCamera();
	CCActionInterval* reverse();
};
class CCAccelAmplitude : public CCActionInterval {
	static CCAccelAmplitude* create(CCAction* pAction, float duration);
	void startWithTarget(CCNode* pTarget);
	CCActionInterval* reverse();
	void update(float time);
	float getRate();
	void setRate(float fRate);
	bool initWithAction(CCAction* pAction, float duration);
	~CCAccelAmplitude();
};
class CCArmatureData : public CCObject {
	string name;
	CCDictionary boneDataDic;
	float dataVersion;
	static CCArmatureData* create();
	void addBoneData(CCBoneData* boneData);
	bool init();
	~CCArmatureData();
	CCBoneData* getBoneData(const char* boneName);
};
class CCScaleTo : public CCActionInterval {
	static CCScaleTo* create @ createfff(float duration, float sx, float sy);
	static CCScaleTo* create @ createff(float duration, float s);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration @ initWithDurationfff(float duration, float sx, float sy);
	bool initWithDuration @ initWithDurationff(float duration, float s);
	void update(float time);
};
class CCParticleSystem : public CCNode, public CCTextureProtocol {
	bool m_bTransformSystemDirty;
	unsigned int m_uAllocatedParticles;
	bool m_bIsActive;
	bool m_bIsBlendAdditive;
	static CCParticleSystem* create(const char* plistFile);
	static CCParticleSystem* createWithTotalParticles(unsigned int numberOfParticles);
	float getStartSizeVar();
	CCTexture2D* getTexture();
	bool isFull();
	CCParticleBatchNode* getBatchNode();
	const ccColor4F& getStartColor();
	tCCPositionType getPositionType();
	void setPosVar(const CCPoint& var);
	float getEndSpin();
	void setRotatePerSecondVar(float degrees);
	float getStartSpinVar();
	float getEndSpinVar();
	void stopSystem();
	bool init();
	float getEndSizeVar();
	void setRotation(float newRotation);
	void setTangentialAccel(float t);
	void setScaleY(float newScaleY);
	void setScaleX(float newScaleX);
	float getRadialAccel();
	void setStartRadius(float startRadius);
	void setRotatePerSecond(float degrees);
	void setEndSize(float var);
	const CCPoint& getGravity();
	float getTangentialAccel();
	void setEndRadius(float endRadius);
	float getAngle();
	float getSpeed();
	void setEndColor(const ccColor4F& var);
	void setStartSpin(float var);
	void setDuration(float var);
	bool initWithTotalParticles(unsigned int numberOfParticles);
	void setTexture(CCTexture2D* var);
	const CCPoint& getPosVar();
	void updateWithNoTime();
	bool isBlendAdditive();
	float getAngleVar();
	void setPositionType(tCCPositionType var);
	float getEndRadius();
	const CCPoint& getSourcePosition();
	void setLifeVar(float var);
	void setTotalParticles(unsigned int var);
	void setEndColorVar(const ccColor4F& var);
	unsigned int getAtlasIndex();
	float getStartSize();
	void setStartSpinVar(float var);
	void resetSystem();
	void setAtlasIndex(unsigned int var);
	void setTangentialAccelVar(float t);
	void setEndRadiusVar(float endRadiusVar);
	bool isActive();
	void setRadialAccelVar(float t);
	void setStartSize(float var);
	void setSpeed(float speed);
	float getStartSpin();
	float getRotatePerSecond();
	void setEmitterMode(int var);
	float getDuration();
	void setSourcePosition(const CCPoint& var);
	float getRadialAccelVar();
	void setBlendAdditive(bool value);
	void setLife(float var);
	void setAngleVar(float var);
	void setRotationIsDir(bool t);
	~CCParticleSystem();
	void setEndSizeVar(float var);
	void setAngle(float var);
	void setBatchNode(CCParticleBatchNode* var);
	float getTangentialAccelVar();
	int getEmitterMode();
	void setEndSpinVar(float var);
	bool initWithFile(const char* plistFile);
	float getSpeedVar();
	void setStartColor(const ccColor4F& var);
	float getRotatePerSecondVar();
	float getEndSize();
	float getLife();
	void setSpeedVar(float speed);
	void setAutoRemoveOnFinish(bool var);
	void setGravity(const CCPoint& g);
	void postStep();
	void setEmissionRate(float var);
	const ccColor4F& getEndColorVar();
	bool getRotationIsDir();
	void setScale(float s);
	float getEmissionRate();
	const ccColor4F& getEndColor();
	float getLifeVar();
	void setStartSizeVar(float var);
	void setOpacityModifyRGB(bool var);
	bool addParticle();
	bool getOpacityModifyRGB();
	float getStartRadius();
	unsigned int getParticleCount();
	float getStartRadiusVar();
	ccBlendFunc getBlendFunc();
	void setStartColorVar(const ccColor4F& var);
	void setEndSpin(float var);
	void update(float dt);
	void setRadialAccel(float t);
	bool initWithDictionary @ initWithDictionarypCpcc(CCDictionary* dictionary, const char* dirname);
	bool initWithDictionary @ initWithDictionarypC(CCDictionary* dictionary);
	bool isAutoRemoveOnFinish();
	unsigned int getTotalParticles();
	void setStartRadiusVar(float startRadiusVar);
	void setBlendFunc(ccBlendFunc var);
	float getEndRadiusVar();
	const ccColor4F& getStartColorVar();
};
class CCEaseExponentialInOut : public CCActionEase {
	static CCEaseExponentialInOut* create(CCActionInterval* pAction);
	CCActionInterval* reverse();
	void update(float time);
	CCObject* copyWithZone(CCZone* pZone);
};
class UIHelper {
	static Widget* seekActionWidgetByActionTag(Widget* root, int tag);
	static Widget* seekWidgetByTag(Widget* root, int tag);
	static Widget* seekWidgetByRelativeName(Widget* root, const char* name);
	static Widget* seekWidgetByName(Widget* root, const char* name);
};
class CCSpawn : public CCActionInterval {
	static CCSpawn* create(CCArray* arrayOfActions);
	static CCSpawn* createWithTwoActions(CCFiniteTimeAction* pAction1, CCFiniteTimeAction* pAction2);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	void stop();
	void update(float time);
	bool initWithTwoActions(CCFiniteTimeAction* pAction1, CCFiniteTimeAction* pAction2);
	~CCSpawn();
	CCActionInterval* reverse();
};
class TimelineActionData : public CCObject {
	static TimelineActionData* create(int actionTag);
	void setActionTag(int actionTag);
	int getActionTag();
};
class CCComController : public CCComponent, public CCInputDelegate {
	static CCComController* create();
	static CCObject* createInstance();
	void setEnabled(bool b);
	void onEnter();
	void onExit();
	bool isEnabled();
	void update(float delta);
	~CCComController();
	bool init();
};
class CCTransitionFade : public CCTransitionScene {
	static CCTransitionFade* create @ createfpC(float duration, CCScene* scene);
	static CCTransitionFade* create @ createfpCrcc(float duration, CCScene* scene, const ccColor3B& color);
	~CCTransitionFade();
	void onEnter();
	void onExit();
	bool initWithDuration @ initWithDurationfpC(float t, CCScene* scene);
	bool initWithDuration @ initWithDurationfpCrcc(float t, CCScene* scene, const ccColor3B& color);
};
class CCObject : public CCCopying {
	unsigned int m_uID;
	int m_nLuaID;
	CCObject* copy();
	unsigned int retainCount();
	void acceptVisitor(CCDataVisitor& visitor);
	bool isEqual(const CCObject* pObject);
	void update(float dt);
	CCObject* autorelease();
	bool isSingleReference();
	void release();
	void retain();
	~CCObject();
};
class CCRGBAProtocol {
	bool isOpacityModifyRGB();
	void setColor(const ccColor3B& color);
	const ccColor3B& getDisplayedColor();
	const ccColor3B& getColor();
	unsigned char getDisplayedOpacity();
	void setCascadeColorEnabled(bool cascadeColorEnabled);
	void setOpacity(unsigned char opacity);
	void setOpacityModifyRGB(bool bValue);
	void setCascadeOpacityEnabled(bool cascadeOpacityEnabled);
	void updateDisplayedOpacity(unsigned char opacity);
	bool isCascadeColorEnabled();
	unsigned char getOpacity();
	bool isCascadeOpacityEnabled();
	void updateDisplayedColor(const ccColor3B& color);
};
class CCFlash : public CCActionInterval {
	static CCFlash* create(float duration, ccColor3B c);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	void stop();
	void update(float time);
	~CCFlash();
	bool initWithDurationAndColor(float d, ccColor3B c);
	CCActionInterval* reverse();
};
class CCMWFileData : public CCAFCFileData {
	unsigned int m_numOfImage;
	int m_numOfAnimation;
	~CCMWFileData();
};
class CCFollow : public CCAction {
	static CCFollow* create(CCNode* pFollowedNode, const CCRect& rect);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithTarget(CCNode* pFollowedNode, const CCRect& rect);
	void stop();
	void setBoudarySet(bool bValue);
	~CCFollow();
	void step(float dt);
	bool isDone();
	bool isBoundarySet();
};
class CCAnimationData : public CCObject {
	string name;
	CCDictionary movementDataDic;
	static CCAnimationData* create();
	CCMovementData* getMovement(const char* movementName);
	int getMovementCount();
	~CCAnimationData();
	void addMovement(CCMovementData* movData);
};
class CCThread {
	void createAutoreleasePool();
	~CCThread();
	CCThread();
};
class CCSkewTo : public CCActionInterval {
	static CCSkewTo* create(float t, float sx, float sy);
	void startWithTarget(CCNode* pTarget);
	void update(float time);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float t, float sx, float sy);
};
class UICCTextField : public CCTextFieldTTF, public CCTextFieldDelegate {
	static UICCTextField* create(const char* placeholder, const char* fontName, float fontSize);
	bool onTextFieldAttachWithIME(CCTextFieldTTF* pSender);
	void setPasswordText(const char* text);
	void setAttachWithIME(bool attach);
	void onEnter();
	bool getDeleteBackward();
	bool getAttachWithIME();
	bool onTextFieldDeleteBackward(CCTextFieldTTF* pSender, const char* delText, int nLen);
	bool getInsertText();
	void deleteBackward();
	void setInsertText(bool insert);
	bool getDetachWithIME();
	~UICCTextField();
	int getCharCount();
	void closeIME();
	void setPasswordEnabled(bool enable);
	void setMaxLengthEnabled(bool enable);
	void setPasswordStyleText(const char* styleText);
	void insertText(const char* text, int len);
	bool isPasswordEnabled();
	bool onTextFieldInsertText(CCTextFieldTTF* pSender, const char* text, int nLen);
	bool onTextFieldDetachWithIME(CCTextFieldTTF* pSender);
	int getMaxLength();
	bool isMaxLengthEnabled();
	void openIME();
	void setDetachWithIME(bool detach);
	void setMaxLength(int length);
	void setDeleteBackward(bool deleteBackward);
};
class ActionScaleFrame : public ActionFrame {
	void setScaleY(float scaleY);
	void setScaleX(float scaleX);
	float getScaleY();
	float getScaleX();
	~ActionScaleFrame();
	CCActionInterval* getAction(float fDuration);
};
class CCEaseElastic : public CCActionEase {
	static CCEaseElastic* create @ createpC(CCActionInterval* pAction);
	static CCEaseElastic* create @ createpCf(CCActionInterval* pAction, float fPeriod);
	CCObject* copyWithZone(CCZone* pZone);
	void setPeriod(float fPeriod);
	bool initWithAction(CCActionInterval* pAction, float fPeriod);
	float getPeriod();
	CCActionInterval* reverse();
};
class CCScrollView : public CCLayer {
	static CCScrollView* create @ create();
	static CCScrollView* create @ createCpC(CCSize size, CCNode* container);
	bool isClippingToBounds();
	void setContainer(CCNode* pContainer);
	void setContentOffsetInDuration(CCPoint offset, float dt);
	void setZoomScaleInDuration(float s, float dt);
	void addChild @ addChildpCi(CCNode* child, int zOrder);
	void addChild @ addChildpCii(CCNode* child, int zOrder, int tag);
	void addChild @ addChildpC(CCNode* child);
	bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	CCNode* getContainer();
	void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	CCScrollViewDirection getDirection();
	void setMinScale(float s);
	float getZoomScale();
	int getScriptHandler(int nScriptEventType);
	void updateInset();
	bool initWithViewSize(CCSize size, CCNode* container);
	void pause(CCObject* sender);
	void setDirection(CCScrollViewDirection eDirection);
	void registerScriptHandler(int nFunID, int nScriptEventType);
	void visit();
	void setBounceable(bool bBounceable);
	void setContentOffset(CCPoint offset, bool animated);
	~CCScrollView();
	bool isDragging();
	bool init();
	bool isBounceable();
	const CCSize& getContentSize();
	void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	void setTouchEnabled(bool e);
	CCPoint getContentOffset();
	void resume(CCObject* sender);
	void setClippingToBounds(bool bClippingToBounds);
	void setViewSize(CCSize size);
	CCSize getViewSize();
	CCPoint maxContainerOffset();
	void setDelegate(CCScrollViewDelegate* pDelegate);
	void setContentSize(const CCSize& size);
	void setMaxScale(float s);
	bool isTouchMoved();
	CCScrollViewDelegate* getDelegate();
	void unregisterScriptHandler(int nScriptEventType);
	bool isNodeVisible(CCNode* node);
	void ccTouchCancelled(CCTouch* pTouch, CCEvent* pEvent);
	CCPoint minContainerOffset();
	CCPoint getTouchPoint();
	void registerWithTouchDispatcher();
	void setZoomScale @ setZoomScalefb(float s, bool animated);
	void setZoomScale @ setZoomScalef(float s);
};
class CCDouble : public CCObject {
	static CCDouble* create(double v);
	double getValue();
	void acceptVisitor(CCDataVisitor& visitor);
};
class CCTimer : public CCObject {
	static CCTimer* timerWithScriptHandler(int nHandler, float fSeconds);
	float getInterval();
	void setInterval(float fInterval);
	bool initWithScriptHandler(int nHandler, float fSeconds);
	void update(float dt);
	int getScriptHandler();
};
class CCTransitionFlipY : public CCTransitionSceneOriented {
	static CCTransitionFlipY* create @ createfpC(float t, CCScene* s);
	static CCTransitionFlipY* create @ createfpCt(float t, CCScene* s, tOrientation o);
	~CCTransitionFlipY();
	void onEnter();
};
class CCTransitionFlipX : public CCTransitionSceneOriented {
	static CCTransitionFlipX* create @ createfpC(float t, CCScene* s);
	static CCTransitionFlipX* create @ createfpCt(float t, CCScene* s, tOrientation o);
	~CCTransitionFlipX();
	void onEnter();
};
class CCCardinalSplineTo : public CCActionInterval {
	static CCCardinalSplineTo* create(float duration, CCPointArray* points, float tension);
	void startWithTarget(CCNode* pTarget);
	CCCardinalSplineTo* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, CCPointArray* points, float tension);
	CCPointArray* getPoints();
	void setPoints(CCPointArray* points);
	void update(float time);
	~CCCardinalSplineTo();
	void updatePosition(CCPoint& newPos);
	CCActionInterval* reverse();
};
class CCTextureCache : public CCObject {
	static CCTextureCache* sharedTextureCache();
	static void purgeSharedTextureCache();
	static void reloadAllTextures();
	void dumpCachedTextureInfo();
	bool reloadTexture(const char* fileName);
	CCTexture2D* addETCImage(const char* filename);
	const char* description();
	CCTexture2D* addUIImage(CCImage* image, const char* key);
	void removeTextureForKey(const char* textureKeyName);
	CCTexture2D* textureForKey(const char* key);
	CCDictionary* snapshotTextures();
	CCTexture2D* addPVRImage(const char* filename);
	~CCTextureCache();
	CCTexture2D* addImage(const char* fileimage);
	void removeAllTextures();
	void removeUnusedTextures();
	void removeTexture(CCTexture2D* texture);
};
class FrameCreateCallFunc : public CCObject {
	~FrameCreateCallFunc();
};
class CCMeasurableProtocol {
	float getPercentage();
	void setPercentage(float p);
};
class CCEaseIn : public CCEaseRateAction {
	static CCEaseIn* create(CCActionInterval* pAction, float fRate);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCMovementData : public CCObject {
	string name;
	int duration;
	float scale;
	int durationTo;
	int durationTween;
	bool loop;
	CCTweenType tweenEasing;
	CCDictionary movBoneDataDic;
	static CCMovementData* create();
	void addMovementBoneData(CCMovementBoneData* movBoneData);
	CCMovementBoneData* getMovementBoneData(const char* boneName);
	~CCMovementData();
};
class CCTiledGrid3DAction : public CCGridAction {
	static CCTiledGrid3DAction* create(float duration, const CCSize& gridSize);
	ccQuad3 tile(const CCPoint& position);
	void setTile(const CCPoint& position, const ccQuad3& coords);
	ccQuad3 originalTile(const CCPoint& position);
	CCGridBase* getGrid();
};
class CCArmatureAnimation : public CCProcessBase {
	float m_fSpeedScale;
	string m_strMovementID;
	int m_iToIndex;
	bool m_bIgnoreFrameEvent;
	bool m_bOnMovementList;
	bool m_bMovementListLoop;
	unsigned int m_uMovementIndex;
	int m_iMovementListDurationTo;
	static CCArmatureAnimation* create(CCArmature* armature);
	CCObject* getUserObject();
	void setScriptObjectDict(CCDictionary* pScriptObjectDict);
	float getSpeedScale();
	void pause();
	void setSpeedScale(float speedScale);
	~CCArmatureAnimation();
	bool init(CCArmature* armature);
	void play(const char* animationName, int durationTo, int durationTween, int loop, int tweenEasing);
	void setUserObject(CCObject* pUserObject);
	void gotoAndPause(int frameIndex);
	void resume();
	void stop();
	void update(float dt);
	CCAnimationData* getAnimationData();
	CCDictionary* getScriptObjectDict();
	void playWithArray(CCArray* movementNames, int durationTo, bool loop);
	void playWithIndexArray(CCArray* movementIndexes, int durationTo, bool loop);
	void playWithIndex(int animationIndex, int durationTo, int durationTween, int loop, int tweenEasing);
	string getCurrentMovementID();
	void setAnimationData(CCAnimationData* var);
	void gotoAndPlay(int frameIndex);
	int getMovementCount();
};
class CCSPX3Loader {
	static CCSPX3FileData* load(const char* spxPath);
};
class CCAccelerometerDelegate {
	void didAccelerate(CCAcceleration* pAccelerationValue);
};
class CCClipOut : public CCActionInterval {
	static CCClipOut* create(float duration, CCPoint v);
	void startWithTarget(CCNode* pTarget);
	CCActionInterval* reverse();
	bool initWithDuration(float d, const CCPoint& v);
	void setDirection(const CCPoint& var);
	void update(float time);
	~CCClipOut();
	const CCPoint& getDirection();
};
class CCShuffleTiles : public CCTiledGrid3DAction {
	static CCShuffleTiles* create(float duration, const CCSize& gridSize, unsigned int seed);
	void startWithTarget(CCNode* pTarget);
	bool initWithDuration(float duration, const CCSize& gridSize, unsigned int seed);
	CCSize getDelta(const CCSize& pos);
	void update(float time);
	~CCShuffleTiles();
	void shuffle(unsigned int* pArray, unsigned int nLen);
	CCObject* copyWithZone(CCZone* pZone);
};
class CCSPX3FileData : public CCAFCFileData {
	int m_version;
	int m_tileSetCount;
	int m_frameCount;
	int m_actionCount;
	static CCSPX3FileData* create();
	CCSPX3Action* getActionAt(int index);
	CCSPX3TileSet* getTileSetAt(int index);
	CCSPX3Frame* getFrameAt(int index);
	~CCSPX3FileData();
};
class CCAutoreleasePool : public CCObject {
	void addObject(CCObject* pObject);
	void clear();
	~CCAutoreleasePool();
	void removeObject(CCObject* pObject);
};
class CCConfiguration : public CCObject {
	static CCConfiguration* sharedConfiguration();
	static void purgeConfiguration();
	bool checkForGLExtension(const string& searchName);
	CCObject* getObject(const char* key);
	void setObject(const char* key, CCObject* value);
	double getNumber(const char* key, double default_value);
	bool supportsPVRTC();
	bool supportsShareableVAO();
	const char* getCString(const char* key, const char* default_value);
	bool getBool(const char* key, bool default_value);
	int getMaxTextureUnits();
	bool supportsNPOT();
	int getMaxModelviewStackDepth();
	bool supportsDiscardFramebuffer();
	bool init();
	void gatherGPUInfo();
	void dumpInfo();
	void loadConfigFile(const char* filename);
	~CCConfiguration();
	int getMaxTextureSize();
	bool supportsBGRA8888();
};
class CCEaseRateAction : public CCActionEase {
	static CCEaseRateAction* create(CCActionInterval* pAction, float fRate);
	CCObject* copyWithZone(CCZone* pZone);
	float getRate();
	~CCEaseRateAction();
	void setRate(float rate);
	bool initWithAction(CCActionInterval* pAction, float fRate);
	CCActionInterval* reverse();
};
class CCEGLViewProtocol {
	void setFrameSize(float width, float height);
	const CCRect& getViewPortRect();
	void setIMEKeyboardState(bool bOpen);
	void setScissorInPoints(float x, float y, float w, float h);
	const char* getViewName();
	bool isOpenGLReady();
	void end();
	float getScaleY();
	float getScaleX();
	CCPoint getVisibleOrigin();
	const CCSize& getFrameSize();
	~CCEGLViewProtocol();
	const CCSize& getDesignResolutionSize();
	void swapBuffers();
	void setDesignResolutionSize(float width, float height, ResolutionPolicy resolutionPolicy);
	void setViewPortInPoints(float x, float y, float w, float h);
	CCRect getScissorRect();
	void setTouchDelegate(EGLTouchDelegate* pDelegate);
	void setViewName(const char* pszViewName);
	CCSize getVisibleSize();
	bool isScissorEnabled();
};
class CCTransitionFadeBL : public CCTransitionFadeTR {
	static CCTransitionFadeBL* create(float t, CCScene* scene);
	CCActionInterval* actionWithSize(const CCSize& size);
	~CCTransitionFadeBL();
};
class CCCatmullRomSprite : public CCNodeRGBA, public CCBlendProtocol {
	static CCCatmullRomSprite* create(const char* fileImage);
	static CCCatmullRomSprite* createWithSprite(CCSprite* sprite);
	static CCCatmullRomSprite* createWithTexture(CCTexture2D* tex);
	static CCCatmullRomSprite* createWithSpriteFrameName(const char* name);
	static CCCatmullRomSprite* createWithSpriteFrame(CCSpriteFrame* frame);
	void setControlPoints(CCPointArray& pa);
	void draw();
	ccBlendFunc getBlendFunc();
	void setBlendFunc(ccBlendFunc blendFunc);
	void resetSegmentVisibility();
	bool isSegmentVisible(int sIndex);
	void setTension(float t);
	void setOpacity(unsigned char opacity);
	~CCCatmullRomSprite();
	int getControlPointCount();
	void addControlPoint(const CCPoint& p);
	int getSegmentCount();
	CCSprite* getPatternSprite();
	void setSegmentVisible(int sIndex, bool visible);
};
class ScrollInnerContainer : public Layout {
	static ScrollInnerContainer* create();
	~ScrollInnerContainer();
	const CCSize& getLayoutSize();
};
class CCTransitionProgressRadialCW : public CCTransitionProgress {
	static CCTransitionProgressRadialCW* create(float t, CCScene* scene);
};
class CCPointList : public CCObject {
	static CCPointList* create();
	void addPoint @ addPointC(CCPoint p);
	void addPoint @ addPointff(float x, float y);
	CCPoint* getBuffer();
	void addPoints(CCPointList& plist);
	void clear();
	CCPoint getPointAt(int index);
	~CCPointList();
	int getCount();
	void deletePointAt(int index);
};
class CCMemoryOutputStream : public CCAssetOutputStream {
	static CCMemoryOutputStream* create @ createulb(unsigned long capacity, bool release);
	static CCMemoryOutputStream* create @ create();
	void reset();
	unsigned long getLength();
	~CCMemoryOutputStream();
	int write @ writepciul(const int* data, unsigned long len);
	int write @ writepccul(const char* data, unsigned long len);
	void close();
	const char* getBuffer();
	unsigned long seek(int offset, int mode);
	unsigned long getPosition();
};
class CCUDPSocket : public CCObject {
	static CCUDPSocket* create(const string& hostname, int port, int tag, int blockSec);
	void setServerAddress(const sockaddr_in& var);
	void setHub(CCUDPSocketHub* var);
	const string& getHostname();
	void clearStop();
	bool isStop();
	const sockaddr_in& getServerAddress();
	const CCArray& getSendQueue();
	void setStop(bool var);
	bool isConnected();
	~CCUDPSocket();
	void markStop();
	int getSocket();
	void sendPacket(CCPacket* p);
	int getTag();
	CCUDPSocketHub* getHub();
	int getPort();
};
class CCTransitionTurnOffTiles : public CCTransitionScene, public CCTransitionEaseScene {
	static CCTransitionTurnOffTiles* create(float t, CCScene* scene);
	CCActionInterval* easeActionWithAction(CCActionInterval* action);
	~CCTransitionTurnOffTiles();
	void onEnter();
};
class CCBlink : public CCActionInterval {
	static CCBlink* create(float duration, unsigned int uBlinks);
	void startWithTarget(CCNode* pTarget);
	CCActionInterval* reverse();
	bool initWithDuration(float duration, unsigned int uBlinks);
	void stop();
	void update(float time);
	CCObject* copyWithZone(CCZone* pZone);
};
class CCMenuItemColor : public CCMenuItem, public CCBlendProtocol {
	static CCMenuItemColor* create @ createcc(ccColor4B normal, ccColor4B selected);
	static CCMenuItemColor* create @ createc(ccColor4B normal);
	static CCMenuItemColor* create @ createccc(ccColor4B normal, ccColor4B selected, ccColor4B focus);
	static CCMenuItemColor* create @ createcccc(ccColor4B normal, ccColor4B selected, ccColor4B focus, ccColor4B disabled);
	void setEnabledSilent(bool value);
	void setEnabled(bool value);
	void draw();
	ccBlendFunc getBlendFunc();
	void setFocus(bool var);
	void setBlendFunc(ccBlendFunc var);
	void selected();
	CCMenuItemColorStateListener* getStateListener();
	~CCMenuItemColor();
	void unselectedSilent();
	void setFocusSilent(bool flag);
	void selectedSilent();
	bool isFocus();
	void setContentSize(const CCSize& size);
	void setStateListener(CCMenuItemColorStateListener* var);
	void unselected();
};
class CCCallFunc : public CCActionInstant {
	static CCCallFunc* create(int nHandler);
	void execute();
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithTarget(CCObject* pSelectorTarget);
	void update(float time);
	~CCCallFunc();
	CCObject* getTargetCallback();
	int getScriptHandler();
	void setTargetCallback(CCObject* pSel);
};
class CCDevice {
	static int getDPI();
};
class CCEditBoxDelegate {
	void editBoxReturn(CCEditBox* editBox);
	void editBoxEditingDidEnd(CCEditBox* editBox);
	void editBoxTextChanged(CCEditBox* editBox, const string& text);
	void editBoxEditingDidBegin(CCEditBox* editBox);
	~CCEditBoxDelegate();
};
class CCTransitionProgressHorizontal : public CCTransitionProgress {
	static CCTransitionProgressHorizontal* create(float t, CCScene* scene);
};
class CCProgressTimer : public CCNodeRGBA, public CCMeasurableProtocol {
	bool m_bReverseDirection;
	static CCProgressTimer* create(CCSprite* sp);
	void setAnchorPoint(CCPoint anchorPoint);
	void setBarChangeRate(CCPoint var);
	void setReverseDirection(bool value);
	void setMidpoint(CCPoint var);
	void setPercentage(float fPercentage);
	void setType(CCProgressTimerType type);
	float getPercentage();
	void setSprite(CCSprite* pSprite);
	void setOpacity(unsigned char opacity);
	CCSprite* getSprite();
	~CCProgressTimer();
	unsigned char getOpacity();
	CCPoint getMidpoint();
	void draw();
	const ccColor3B& getColor();
	CCProgressTimerType getType();
	void setReverseProgress(bool reverse);
	bool isReverseDirection();
	void setColor(const ccColor3B& color);
	CCPoint getBarChangeRate();
	bool initWithSprite(CCSprite* sp);
};
class CCMemory {
	static void usageReport();
	static void dumpRecord();
};
class CCCurl : public CCActionInterval {
	static CCCurl* create(float duration, CCPoint center, float toRadius, float angularVelocity);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float d, CCPoint center, float toRadius, float angularVelocity);
	void update(float time);
	~CCCurl();
	CCActionInterval* reverse();
};
class CCTwirl : public CCGrid3DAction {
	static CCTwirl* create(float duration, const CCSize& gridSize, CCPoint position, unsigned int twirls, float amplitude);
	void setAmplitudeRate(float fAmplitudeRate);
	bool initWithDuration(float duration, const CCSize& gridSize, CCPoint position, unsigned int twirls, float amplitude);
	void update(float time);
	float getAmplitudeRate();
	void setAmplitude(float fAmplitude);
	float getAmplitude();
	void setPosition(const CCPoint& position);
	const CCPoint& getPosition();
	CCObject* copyWithZone(CCZone* pZone);
};
class CCInvocation : public CCObject {
	void invoke(CCObject* sender);
	unsigned int getControlEvent();
	CCObject* getTarget();
};
class CCEaseBezierAction : public CCActionEase {
	static CCEaseBezierAction* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void setBezierParamer(float p0, float p1, float p2, float p3);
	void update(float time);
	CCActionInterval* reverse();
};
class CCWaves : public CCGrid3DAction {
	static CCWaves* create(float duration, const CCSize& gridSize, unsigned int waves, float amplitude, bool horizontal, bool vertical);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCSize& gridSize, unsigned int waves, float amplitude, bool horizontal, bool vertical);
	void update(float time);
	float getAmplitudeRate();
	void setAmplitude(float fAmplitude);
	float getAmplitude();
	void setAmplitudeRate(float fAmplitudeRate);
};
class CCTransitionZoomFlipAngular : public CCTransitionSceneOriented {
	static CCTransitionZoomFlipAngular* create @ createfpC(float t, CCScene* s);
	static CCTransitionZoomFlipAngular* create @ createfpCt(float t, CCScene* s, tOrientation o);
	~CCTransitionZoomFlipAngular();
	void onEnter();
};
class CCSPXLoader {
	static CCSPXFileData* load(const char* spxPath);
};
class CCInputDelegate : public CCTouchDelegate, public CCAccelerometerDelegate, public CCKeypadDelegate {
	bool isAccelerometerEnabled();
	void setTouchEnabled(bool value);
	void didAccelerate(CCAcceleration* pAccelerationValue);
	int getTouchMode();
	void setAccelerometerEnabled(bool value);
	bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	void setKeypadEnabled(bool value);
	bool isKeypadEnabled();
	void ccTouchesCancelled(CCSet* pTouches, CCEvent* pEvent);
	~CCInputDelegate();
	void ccTouchCancelled(CCTouch* pTouch, CCEvent* pEvent);
	void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	bool isTouchEnabled();
	void ccTouchesBegan(CCSet* pTouches, CCEvent* pEvent);
	void setTouchPriority(int priority);
	void ccTouchesMoved(CCSet* pTouches, CCEvent* pEvent);
	void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	int getTouchPriority();
	void ccTouchesEnded(CCSet* pTouches, CCEvent* pEvent);
	void setTouchMode(ccTouchesMode mode);
};
class CCLens3D : public CCGrid3DAction {
	static CCLens3D* create(float duration, const CCSize& gridSize, const CCPoint& position, float radius);
	void setConcave(bool bConcave);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCSize& gridSize, const CCPoint& position, float radius);
	void setLensEffect(float fLensEffect);
	void update(float time);
	float getLensEffect();
	void setPosition(const CCPoint& position);
	const CCPoint& getPosition();
};
class CCAFCFrame : public CCObject {
	static CCAFCFrame* create();
	void addClip(CCAFCClip* clip);
	float getDelay();
	void setIncrementation(ccPoint inc);
	void setUseTickDelay(bool flag);
	int getClipCount @ getClipCountC(CCAFCClipType type);
	int getClipCount @ getClipCount();
	void setFlipY(bool flag);
	void setFlipX(bool flag);
	bool isFlipX();
	bool isFlipY();
	~CCAFCFrame();
	bool isUseTickDelay();
	CCAFCClip* getClipAt @ getClipAtCi(CCAFCClipType type, int index);
	CCAFCClip* getClipAt @ getClipAti(int index);
	void setDelay(float delay);
	ccPoint getIncrementation();
};
class CCControlSlider : public CCControl {
	static CCControlSlider* create(CCSprite* bg, CCSprite* thumb, CCSprite* progress);
	bool ccTouchBegan(CCTouch* touch, CCEvent* pEvent);
	void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	void markDiscreteMode();
	float getMaximumAllowedValue();
	float getMinimumAllowedValue();
	float getMinimumValue();
	void setThumbSprite(CCSprite* var);
	~CCControlSlider();
	void setMinimumValue(float var);
	void setMinimumAllowedValue(float var);
	void setProgressSprite(CCSprite* var);
	void clearDiscreteMode();
	void setValue(float var);
	void setMaximumValue(float var);
	void needsLayout();
	void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	void setDiscreteMode(bool var);
	CCSprite* getBackgroundSprite();
	int getIntValue();
	float getMaximumValue();
	float getValue();
	void ccTouchCancelled(CCTouch* pTouch, CCEvent* pEvent);
	CCSprite* getThumbSprite();
	bool isDiscreteMode();
	CCSprite* getProgressSprite();
	void setBackgroundSprite(CCSprite* var);
	void setMaximumAllowedValue(float var);
};
class CCLayerGradient : public CCLayerColor {
	static CCLayerGradient* create @ createrccrccrcC(const ccColor4B& start, const ccColor4B& end, const CCPoint& v);
	static CCLayerGradient* create @ createrccrcc(const ccColor4B& start, const ccColor4B& end);
	static CCLayerGradient* create @ create();
	const ccColor3B& getStartColor();
	bool isCompressedInterpolation();
	unsigned char getStartOpacity();
	void setVector(const CCPoint& var);
	void setStartOpacity(unsigned char var);
	void setCompressedInterpolation(bool bCompressedInterpolation);
	void setEndOpacity(unsigned char var);
	const CCPoint& getVector();
	bool init();
	void setEndColor(const ccColor3B& var);
	bool initWithColor @ initWithColorrccrccrcC(const ccColor4B& start, const ccColor4B& end, const CCPoint& v);
	bool initWithColor @ initWithColorrccrcc(const ccColor4B& start, const ccColor4B& end);
	const ccColor3B& getEndColor();
	unsigned char getEndOpacity();
	void setStartColor(const ccColor3B& var);
};
class EventFrame : public Frame {
	static EventFrame* create();
	void setEvent(string event);
	string getEvent();
	Frame* clone();
	void onEnter(Frame* nextFrame);
};
class CCTMXObject : public CCObject {
	static CCTMXObject* create();
	string getProperty(const string& key);
	void addProperty(const string& key, const string& value);
	void setName(const string& var);
	CCPointList& getPoints();
	void setSize(const CCSize& var);
	string& getName();
	string& getType();
	~CCTMXObject();
	CCSize& getSize();
	Shape getShape();
	CCDictionary& getProperties();
	void setProperties(const CCDictionary& var);
	void setType(const string& var);
	void setPoints(const CCPointList& var);
	void setPosition(const CCPoint& var);
	CCPoint& getPosition();
	void setShape(Shape var);
	enum Shape {
		NORMAL,
		POLYGON,
		POLYLINE
	};
};
class SkewFrame : public Frame {
	static SkewFrame* create();
	void onEnter(Frame* nextFrame);
	Frame* clone();
	float getSkewY();
	float getSkewX();
	void apply(float percent);
	void setSkewX(float skewx);
	void setSkewY(float skewy);
};
class CCRemoveSelf : public CCActionInstant {
	static CCRemoveSelf* create(bool isNeedCleanUp);
	CCFiniteTimeAction* reverse();
	void update(float time);
	~CCRemoveSelf();
	bool init(bool isNeedCleanUp);
	CCObject* copyWithZone(CCZone* pZone);
};
class CCSkin : public CCSprite {
	static CCSkin* create @ createpcc(const char* pszFileName);
	static CCSkin* create @ create();
	static CCSkin* createWithSpriteFrameName(const char* pszSpriteFrameName);
	CCBone* getBone();
	CCAffineTransform nodeToWorldTransform();
	bool initWithFile(const char* pszFilename);
	CCAffineTransform nodeToWorldTransformAR();
	void updateTransform();
	string getDisplayName();
	void updateArmatureTransform();
	bool initWithSpriteFrameName(const char* pszSpriteFrameName);
	void setSkinData(const CCBaseData& var);
	const CCBaseData& getSkinData();
	void setBone(CCBone* var);
};
class CCSplitCols : public CCTiledGrid3DAction {
	static CCSplitCols* create(float duration, unsigned int nCols);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, unsigned int nCols);
	void update(float time);
};
class CCTCPSocket : public CCObject {
	static CCTCPSocket* create(const string& hostname, int port, int tag, int blockSec, bool keepAlive);
	void setStop(bool var);
	void setHub(CCTCPSocketHub* var);
	const string& getHostname();
	void clearStop();
	bool isStop();
	const CCArray& getSendQueue();
	bool hasAvailable();
	bool isConnected();
	~CCTCPSocket();
	void markStop();
	int getSocket();
	void sendPacket(CCPacket* p);
	int getTag();
	CCTCPSocketHub* getHub();
	int getPort();
};
class CCDictElement {
	UT_hash_handle hh;
	CCObject* getObject();
	const char* getStrKey();
	long getIntKey();
	~CCDictElement();
};
class CCSPX3Action : public CCObject {
	CCSPX3ActionMode m_mode;
	CCSPX3Tile m_collisionRect;
	int m_frameCount;
	static CCSPX3Action* create();
	~CCSPX3Action();
};
class CCRenderTexture : public CCNode {
	static CCRenderTexture* create @ createiiC(int w, int h, CCTexture2DPixelFormat eFormat);
	static CCRenderTexture* create @ createiiCui(int w, int h, CCTexture2DPixelFormat eFormat, unsigned int uDepthStencilFormat);
	static CCRenderTexture* create @ createii(int w, int h);
	void clearStencil(int stencilValue);
	void begin();
	void listenToForeground(CCObject* obj);
	float getClearDepth();
	int getClearStencil();
	void end();
	void setClearStencil(float fClearStencil);
	void setSprite(CCSprite* var);
	void visit();
	CCSprite* getSprite();
	~CCRenderTexture();
	bool isAutoDraw();
	void setClearFlags(unsigned int uClearFlags);
	void draw();
	bool saveToFile @ saveToFilepcct(const char* name, tCCImageFormat format);
	bool saveToFile @ saveToFilepcc(const char* szFilePath);
	void setAutoDraw(bool bAutoDraw);
	void setClearColor(const ccColor4F& clearColor);
	void endToLua();
	void beginWithClear @ beginWithClearfffff(float r, float g, float b, float a, float depthValue);
	void beginWithClear @ beginWithClearffff(float r, float g, float b, float a);
	void beginWithClear @ beginWithClearfffffi(float r, float g, float b, float a, float depthValue, int stencilValue);
	void clearDepth(float depthValue);
	const ccColor4F& getClearColor();
	void listenToBackground(CCObject* obj);
	void clear(float r, float g, float b, float a);
	unsigned int getClearFlags();
	CCImage* newCCImage(bool flipImage);
	void setClearDepth(float fClearDepth);
	bool initWithWidthAndHeight @ initWithWidthAndHeightiiCui(int w, int h, CCTexture2DPixelFormat eFormat, unsigned int uDepthStencilFormat);
	bool initWithWidthAndHeight @ initWithWidthAndHeightiiC(int w, int h, CCTexture2DPixelFormat eFormat);
};
class CCControlHuePicker : public CCControl {
	static CCControlHuePicker* create(CCNode* target, CCPoint pos);
	void setEnabled(bool enabled);
	bool initWithTargetAndPos(CCNode* target, CCPoint pos);
	void setHue(float val);
	CCPoint getStartPos();
	float getHue();
	CCSprite* getSlider();
	~CCControlHuePicker();
	void setBackground(CCSprite* var);
	void setHuePercentage(float val);
	CCSprite* getBackground();
	float getHuePercentage();
	void setSlider(CCSprite* var);
};
class RichText : public Widget {
	static RichText* create();
	void insertElement(RichElement* element, int index);
	void setAnchorPoint(const CCPoint& pt);
	void pushBackElement(RichElement* element);
	void formatText();
	void ignoreContentAdaptWithSize(bool ignore);
	void setVerticalSpace(float space);
	void visit();
	~RichText();
	const CCSize& getContentSize();
	void removeElement @ removeElementpR(RichElement* element);
	void removeElement @ removeElementi(int index);
	string getDescription();
};
class TouchGroup : public CCLayer {
	static TouchGroup* create();
	Widget* getRootWidget();
	void removeWidget(Widget* widget);
	void onEnter();
	void onExit();
	bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	Widget* getWidgetByTag(int tag);
	~TouchGroup();
	void ccTouchCancelled(CCTouch* pTouch, CCEvent* pEvent);
	void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	bool init();
	Widget* getWidgetByName(const char* name);
	void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	void addWidget(Widget* widget);
	void clear();
	void onEnterTransitionDidFinish();
};
class CCGrid3D : public CCGridBase {
	static CCGrid3D* create @ creatercC(const CCSize& gridSize);
	static CCGrid3D* create @ creatercCpCb(const CCSize& gridSize, CCTexture2D* pTexture, bool bFlipped);
	void calculateVertexPoints();
	void setVertex(const CCPoint& pos, const ccVertex3F& vertex);
	void reuse();
	ccVertex3F vertex(const CCPoint& pos);
	~CCGrid3D();
	ccVertex3F originalVertex(const CCPoint& pos);
	void blit();
};
class DictionaryHelper {
	static void purgeDictionaryHelper();
	static DictionaryHelper* shareHelper();
	CCDictionary* getSubDictionary(CCDictionary* root, const char* key);
	const char* getStringValue(CCDictionary* root, const char* key);
	float objectToFloatValue(CCObject* obj);
	CCArray* objectToCCArray(CCObject* obj);
	float getFloatValue(CCDictionary* root, const char* key);
	~DictionaryHelper();
	CCObject* checkObjectExist(CCDictionary* root, const char* key);
	bool objectToBooleanValue(CCObject* obj);
	int objectToIntValue(CCObject* obj);
	DictionaryHelper();
	bool getBooleanValue(CCDictionary* root, const char* key);
	int getIntValue(CCDictionary* root, const char* key);
	CCArray* getArrayValue(CCDictionary* root, const char* key);
	const char* objectToStringValue(CCObject* obj);
};
class CCEaseCubicActionInOut : public CCActionEase {
	static CCEaseCubicActionInOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCCamera : public CCObject {
	static float getZEye();
	void locate();
	void restore();
	void setUpXYZ(float fUpX, float fUpY, float fUpZ);
	const char* description();
	void setCenterXYZ(float fCenterX, float fCenterY, float fCenterZ);
	void setEyeXYZ(float fEyeX, float fEyeY, float fEyeZ);
	void getCenterXYZ(float* pCenterX, float* pCenterY, float* pCenterZ);
	void getEyeXYZ(float* pEyeX, float* pEyeY, float* pEyeZ);
	bool isDirty();
	void init();
	void getUpXYZ(float* pUpX, float* pUpY, float* pUpZ);
	void setDirty(bool bValue);
	~CCCamera();
};
class ActionFrame : public CCObject {
	CCActionInterval* getAction @ getActionfpA(float fDuration, ActionFrame* srcFrame);
	CCActionInterval* getAction @ getActionf(float fDuration);
	int getFrameType();
	void setFrameTime(float fTime);
	void setEasingType(int easingType);
	float getFrameTime();
	~ActionFrame();
	int getFrameIndex();
	void setFrameType(int frameType);
	void setFrameIndex(int index);
	int getEasingType();
};
class CCScrollViewDelegate {
	void scrollViewDidScroll(CCScrollView* view);
	void scrollViewDidZoom(CCScrollView* view);
	~CCScrollViewDelegate();
};
class CCAcceleration {
	double x;
	double y;
	double z;
	double timestamp;
};
class CCTableViewCell : public CCNode, public CCSortableObject {
	void reset();
	void setIdx(unsigned int uIdx);
	void setObjectID(unsigned int uIdx);
	void setName(const string& var);
	unsigned int getObjectID();
	const string& getName();
	unsigned int getIdx();
};
class CCTransitionFadeTR : public CCTransitionScene, public CCTransitionEaseScene {
	static CCTransitionFadeTR* create(float t, CCScene* scene);
	CCActionInterval* actionWithSize(const CCSize& size);
	~CCTransitionFadeTR();
	void onEnter();
	CCActionInterval* easeActionWithAction(CCActionInterval* action);
};
class CCScaleBy : public CCScaleTo {
	static CCScaleBy* create @ createfff(float duration, float sx, float sy);
	static CCScaleBy* create @ createff(float duration, float s);
	void startWithTarget(CCNode* pTarget);
	CCActionInterval* reverse();
	CCObject* copyWithZone(CCZone* pZone);
};
class CCTime {
	static int gettimeofdayCocos2d(cc_timeval* tp, void* tzp);
	static double timersubCocos2d(cc_timeval* start, cc_timeval* end);
};
class CCDisplayFactory {
	static void addSpriteDisplay(CCBone* bone, CCDecorativeDisplay* decoDisplay, CCDisplayData* displayData);
	static void initSpriteDisplay(CCBone* bone, CCDecorativeDisplay* decoDisplay, const char* displayName, CCSkin* skin);
	static void createDisplay(CCBone* bone, CCDecorativeDisplay* decoDisplay);
	static void addArmatureDisplay(CCBone* bone, CCDecorativeDisplay* decoDisplay, CCDisplayData* displayData);
	static void updateArmatureDisplay(CCBone* bone, CCNode* display, float dt);
	static void createParticleDisplay(CCBone* bone, CCDecorativeDisplay* decoDisplay);
	static void createSpriteDisplay(CCBone* bone, CCDecorativeDisplay* decoDisplay);
	static void addParticleDisplay(CCBone* bone, CCDecorativeDisplay* decoDisplay, CCDisplayData* displayData);
	static void updateDisplay(CCBone* bone, float dt, bool dirty);
	static void createArmatureDisplay(CCBone* bone, CCDecorativeDisplay* decoDisplay);
	static void updateParticleDisplay(CCBone* bone, CCNode* display, float dt);
	static void addDisplay(CCBone* bone, CCDecorativeDisplay* decoDisplay, CCDisplayData* displayData);
};
class CCEaseInOut : public CCEaseRateAction {
	static CCEaseInOut* create(CCActionInterval* pAction, float fRate);
	CCActionInterval* reverse();
	void update(float time);
	CCObject* copyWithZone(CCZone* pZone);
};
class CCTextureETC : public CCObject {
	bool initWithFile(const char* file);
	unsigned int getName();
	unsigned int getHeight();
	~CCTextureETC();
	unsigned int getWidth();
};
class CCUserDefault {
	static void purgeSharedUserDefault();
	static bool isXMLFileExist();
	static const string& getXMLFilePath();
	static CCUserDefault* sharedUserDefault();
	void setIntegerForKey(const char* pKey, int value);
	float getFloatForKey @ getFloatForKeypccf(const char* pKey, float defaultValue);
	float getFloatForKey @ getFloatForKeypcc(const char* pKey);
	bool getBoolForKey @ getBoolForKeypccb(const char* pKey, bool defaultValue);
	bool getBoolForKey @ getBoolForKeypcc(const char* pKey);
	void setDoubleForKey(const char* pKey, double value);
	void setFloatForKey(const char* pKey, float value);
	~CCUserDefault();
	string getStringForKey @ getStringForKeypccrcs(const char* pKey, const string& defaultValue);
	string getStringForKey @ getStringForKeypcc(const char* pKey);
	void setStringForKey(const char* pKey, const string& value);
	void flush();
	void purgeDefaultForKey(const string& key);
	int getIntegerForKey @ getIntegerForKeypcci(const char* pKey, int defaultValue);
	int getIntegerForKey @ getIntegerForKeypcc(const char* pKey);
	double getDoubleForKey @ getDoubleForKeypccd(const char* pKey, double defaultValue);
	double getDoubleForKey @ getDoubleForKeypcc(const char* pKey);
	void setBoolForKey(const char* pKey, bool value);
};
class CCHide : public CCActionInstant {
	static CCHide* create();
	CCFiniteTimeAction* reverse();
	CCObject* copyWithZone(CCZone* pZone);
	~CCHide();
	void update(float time);
};
class CCShake : public CCActionInterval {
	static CCShake* create @ createfffff(float duration, float startMaxRadius, float endMaxRadius, float startMinRadius, float endMinRadius);
	static CCShake* create @ createfff(float duration, float maxRadius, float minRadius);
	void startWithTarget(CCNode* pTarget);
	CCActionInterval* reverse();
	void update(float t);
	~CCShake();
	bool initWithRing(float d, float maxR, float minR);
	bool initWithDynamicRing(float d, float startMaxR, float endMaxR, float startMinR, float endMinR);
	CCObject* copyWithZone(CCZone* pZone);
};
class CCEaseSineOut : public CCActionEase {
	static CCEaseSineOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCControl : public CCLayerRGBA {
	void onEnter();
	void sendActionsForControlEvents(unsigned int controlEvents);
	void setSelected(bool bSelected);
	bool hasVisibleParents();
	void setHighlighted(bool bHighlighted);
	bool isHighlighted();
	void removeHandleOfControlEvent(unsigned int controlEvent);
	bool isOpacityModifyRGB();
	bool isEnabled();
	void setOpacityModifyRGB(bool bOpacityModifyRGB);
	~CCControl();
	bool isSelected();
	bool init();
	void setEnabled(bool bEnabled);
	unsigned int getState();
	void needsLayout();
	void addHandleOfControlEvent(int nFunID, unsigned int controlEvent);
	CCPoint getTouchLocation(CCTouch* touch);
	void onExit();
	bool isTouchInside(CCTouch* touch);
	void registerWithTouchDispatcher();
};
class CCJumpTiles3D : public CCTiledGrid3DAction {
	static CCJumpTiles3D* create(float duration, const CCSize& gridSize, unsigned int numberOfJumps, float amplitude);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, const CCSize& gridSize, unsigned int numberOfJumps, float amplitude);
	void update(float time);
	float getAmplitudeRate();
	void setAmplitude(float fAmplitude);
	float getAmplitude();
	void setAmplitudeRate(float fAmplitudeRate);
};
class CCParticleSystemQuad : public CCParticleSystem {
	static CCParticleSystemQuad* create @ create();
	static CCParticleSystemQuad* create @ createpcc(const char* plistFile);
	static CCParticleSystemQuad* createWithTotalParticles(unsigned int numberOfParticles);
	void postStep();
	void setBatchNode(CCParticleBatchNode* batchNode);
	void draw();
	void setTexture(CCTexture2D* texture);
	void setTotalParticles(unsigned int tp);
	~CCParticleSystemQuad();
	void initTexCoordsWithRect(const CCRect& rect);
	void setTextureWithRect(CCTexture2D* texture, const CCRect& rect);
	void initIndices();
	void setDisplayFrame(CCSpriteFrame* spriteFrame);
	void listenBackToForeground(CCObject* obj);
	bool initWithTotalParticles(unsigned int numberOfParticles);
};
class CCComRender : public CCComponent {
	static CCComRender* create @ create();
	static CCComRender* create @ createpCpcc(CCNode* pNode, const char* comName);
	static CCObject* createInstance();
	void setNode(CCNode* pNode);
	void onEnter();
	void onExit();
	bool serialize(void* r);
	~CCComRender();
	CCNode* getNode();
};
class CCEaseQuadraticActionIn : public CCActionEase {
	static CCEaseQuadraticActionIn* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class ActionTintFrame : public ActionFrame {
	ccColor3B getColor();
	~ActionTintFrame();
	CCActionInterval* getAction(float fDuration);
	void setColor(ccColor3B ccolor);
};
class ActionFadeFrame : public ActionFrame {
	int getOpacity();
	~ActionFadeFrame();
	CCActionInterval* getAction(float fDuration);
	void setOpacity(int opacity);
};
class CCTrailMoveTo : public CCMoveTo {
	static CCTrailMoveTo* createWithFileName(float duration, const CCPoint& position, const string& fileName, float trailDistance, int trailSegments, ccColor3B trailColor, ccColor4B trailColorScale, bool removeWhenDone);
	static CCTrailMoveTo* createWithSpriteFrameName(float duration, const CCPoint& position, const string& trailFrameName, float trailDistance, int trailSegments, ccColor3B trailColor, ccColor4B trailColorScale, bool removeWhenDone);
	static CCTrailMoveTo* createWithArmature @ createWithArmaturefrcCrcsrcsficcb(float duration, const CCPoint& position, const string& armatureName, const string& animationName, float trailDistance, int trailSegments, ccColor3B trailColor, ccColor4B trailColorScale, bool removeWhenDone);
	static CCTrailMoveTo* createWithArmature @ createWithArmaturefrcCrcsificcb(float duration, const CCPoint& position, const string& armatureName, int animationIndex, float trailDistance, int trailSegments, ccColor3B trailColor, ccColor4B trailColorScale, bool removeWhenDone);
	void setRemoveWhenDone(bool var);
	float gettrailDistance();
	CCObject* copyWithZone(CCZone* pZone);
	void setAnimationIndex(int var);
	void setTrailColorScale(const ccColor4B& var);
	~CCTrailMoveTo();
	bool initWithDurationAndSpriteTrail(float duration, const CCPoint& position, const string& spriteName, float trailDistance, int trailSegments, ccColor3B trailColor, ccColor4B trailColorScale, bool removeWhenDone);
	const ccColor4B& getTrailColorScale();
	void setTrailColor(const ccColor3B& var);
	const ccColor3B& getTrailColor();
	const string& getAnimationName();
	void update(float time);
	void clearRemoveWhenDone();
	bool isRemoveWhenDone();
	void settrailDistance(float var);
	void setAnimationName(const string& var);
	void startWithTarget(CCNode* pTarget);
	int getAnimationIndex();
	bool initWithDurationAndArmatureTrail @ initWithDurationAndArmatureTrailfrcCrcsificcb(float duration, const CCPoint& position, const string& armatureName, int animationIndex, float trailDistance, int trailSegments, ccColor3B trailColor, ccColor4B trailColorScale, bool removeWhenDone);
	bool initWithDurationAndArmatureTrail @ initWithDurationAndArmatureTrailfrcCrcsrcsficcb(float duration, const CCPoint& position, const string& armatureName, const string& animationName, float trailDistance, int trailSegments, ccColor3B trailColor, ccColor4B trailColorScale, bool removeWhenDone);
	void markRemoveWhenDone();
	int getTrailSegments();
	void setTrailSegments(int var);
};
class CCRotateTo : public CCActionInterval {
	static CCRotateTo* create @ createfff(float fDuration, float fDeltaAngleX, float fDeltaAngleY);
	static CCRotateTo* create @ createff(float fDuration, float fDeltaAngle);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration @ initWithDurationfff(float fDuration, float fDeltaAngleX, float fDeltaAngleY);
	bool initWithDuration @ initWithDurationff(float fDuration, float fDeltaAngle);
	void update(float time);
};
class CCEaseQuarticActionIn : public CCActionEase {
	static CCEaseQuarticActionIn* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCCardinalSplineBy : public CCCardinalSplineTo {
	static CCCardinalSplineBy* create(float duration, CCPointArray* points, float tension);
	void startWithTarget(CCNode* pTarget);
	void updatePosition(CCPoint& newPos);
	CCActionInterval* reverse();
};
class CCArmature : public CCNodeRGBA, public CCBlendProtocol {
	static CCArmature* create @ createpcc(const char* name);
	static CCArmature* create @ create();
	static CCArmature* create @ createpccpC(const char* name, CCBone* parentBone);
	CCBone* getBone(const char* name);
	void changeBoneParent(CCBone* bone, const char* parentName);
	void onEnter();
	CCTextureAtlas* getTexureAtlasWithTexture(CCTexture2D* texture);
	void setPreDrawFunction(CCCallFuncO* var);
	void setAnimation(CCArmatureAnimation* animation);
	CCBone* getBoneAtPoint(float x, float y);
	CCBatchNode* getBatchNode();
	void setVersion(float var);
	void updateOffsetPoint();
	CCBone* getParentBone();
	void setName(string var);
	void removeBone(CCBone* bone, bool recursion);
	bool getArmatureTransformDirty();
	string getName();
	void visit();
	~CCArmature();
	bool init @ initpcc(const char* name);
	bool init @ init();
	bool init @ initpccpC(const char* name, CCBone* parentBone);
	void setParentBone(CCBone* var);
	void setBatchNode(CCBatchNode* var);
	void draw();
	ccBlendFunc getBlendFunc();
	CCAffineTransform nodeToParentTransform();
	void setArmatureData(CCArmatureData* var);
	void setTextureAtlas(CCTextureAtlas* var);
	void addBone(CCBone* bone, const char* parentName);
	void update(float dt);
	CCArmatureData* getArmatureData();
	CCCallFuncO* getPreDrawFunction();
	CCRect boundingBox();
	float getVersion();
	CCArmatureAnimation* getAnimation();
	void onExit();
	void setBlendFunc(ccBlendFunc blendFunc);
	CCDictionary* getBoneDic();
	CCTextureAtlas* getTextureAtlas();
};
class CCTiledGrid3D : public CCGridBase {
	static CCTiledGrid3D* create @ creatercC(const CCSize& gridSize);
	static CCTiledGrid3D* create @ creatercCpCb(const CCSize& gridSize, CCTexture2D* pTexture, bool bFlipped);
	void calculateVertexPoints();
	void reuse();
	~CCTiledGrid3D();
	ccQuad3 originalTile(const CCPoint& pos);
	ccQuad3 tile(const CCPoint& pos);
	void setTile(const CCPoint& pos, const ccQuad3& coords);
	void blit();
};
class CCControlColourPicker : public CCControl {
	static CCControlColourPicker* create();
	void setEnabled(bool bEnabled);
	CCControlHuePicker* getHuePicker();
	void setColor(const ccColor3B& colorValue);
	void hueSliderValueChanged(CCObject* sender, unsigned int controlEvent);
	CCControlSaturationBrightnessPicker* getcolourPicker();
	~CCControlColourPicker();
	void setBackground(CCSprite* var);
	bool init();
	void setcolourPicker(CCControlSaturationBrightnessPicker* var);
	void colourSliderValueChanged(CCObject* sender, unsigned int controlEvent);
	void setHuePicker(CCControlHuePicker* var);
	CCSprite* getBackground();
};
class CCAnimationCache : public CCObject {
	static CCAnimationCache* sharedAnimationCache();
	static void purgeSharedAnimationCache();
	void addAnimation(CCAnimation* animation, const char* name);
	void addAnimationsWithFile(const char* plist);
	~CCAnimationCache();
	void removeAnimationByName(const char* name);
	bool init();
	CCAnimation* animationByName(const char* name);
	void addAnimationsWithDictionary(CCDictionary* dictionary, const char* plist);
};
class CCArcticSprite : public CCAFCSprite {
	int getAnimationCount();
	CCAFCAnimation* getAnimationAt(int index, CCAFCClipMapping* mapping);
	CCAFCFileData* getFileData();
	int getImageCount();
	~CCArcticSprite();
};
class CCLayerMultiplex : public CCLayer {
	static CCLayerMultiplex* createWithLayer(CCLayer* layer);
	static CCLayerMultiplex* create();
	static CCLayerMultiplex* createWithArray(CCArray* arrayOfLayers);
	bool initWithArray(CCArray* arrayOfLayers);
	int getEnabledLayer();
	CCLayer* layerAt(int n);
	~CCLayerMultiplex();
	void addLayer(CCLayer* layer);
	void switchTo(unsigned int n);
};
class CCTransitionProgressVertical : public CCTransitionProgress {
	static CCTransitionProgressVertical* create(float t, CCScene* scene);
};
class CCFloat : public CCObject {
	static CCFloat* create(float v);
	float getValue();
	void acceptVisitor(CCDataVisitor& visitor);
};
class ObjectFactory {
	static ObjectFactory* getInstance();
	void registerType(const TInfo& t);
	void destroyInstance();
	CCObject* createObject(string name);
	CCComponent* createComponent(string name);
	~ObjectFactory();
	Widget* createGUI(string name);
	ObjectFactory();
	WidgetReaderProtocol* createWidgetReaderProtocol(string name);
	struct TInfo {
		string _class;
		~TInfo();
		TInfo(const TInfo& t);
		TInfo();
	};
};
class CCAuroraSprite : public CCAFCSprite {
	int getAnimationCount();
	CCAFCAnimation* getAnimationAt(int index, CCAFCClipMapping* mapping);
	CCAFCFileData* getFileData();
	int getImageCount();
	~CCAuroraSprite();
};
class CCComponentContainer {
	CCComponent* get(const char* pName);
	void visit(float fDelta);
	bool remove @ removepC(CCComponent* pCom);
	bool remove @ removepcc(const char* pName);
	~CCComponentContainer();
	void removeAll();
	bool add(CCComponent* pCom);
	bool isEmpty();
};
class CCParticleFlower : public CCParticleSystemQuad {
	static CCParticleFlower* create();
	static CCParticleFlower* createWithTotalParticles(unsigned int numberOfParticles);
	bool init();
	~CCParticleFlower();
	bool initWithTotalParticles(unsigned int numberOfParticles);
};
class CCAFCClipMapping : public CCObject {
	static CCAFCClipMapping* create(int tag);
	static CCAFCClipMapping* createWithAuroraGT(int tag, const char* ammPath);
	CCAFCClipMappingRule* findRule(int sourceClipIndex);
	int getTag();
	void mapClip @ mapClipipcci(int fromClipIndex, const char* externalFilePath, int toClipIndex);
	void mapClip @ mapClipii(int fromClipIndex, int toClipIndex);
	void mapClip @ mapClipipCccbf(int fromClipIndex, CCTexture2D* tex, ccPoint pos, ccRect texRect, bool flipX, float rotation);
	~CCAFCClipMapping();
};
class CCTransitionShrinkGrow : public CCTransitionScene, public CCTransitionEaseScene {
	static CCTransitionShrinkGrow* create(float t, CCScene* scene);
	CCActionInterval* easeActionWithAction(CCActionInterval* action);
	~CCTransitionShrinkGrow();
	void onEnter();
};
class CCBlur : public CCActionInterval {
	static CCBlur* create(float duration, CCSize startBlurSize, CCSize endBlurSize);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	void stop();
	void update(float time);
	~CCBlur();
	bool initWithBlurSize(float d, CCSize startBlurSize, CCSize endBlurSize);
	CCActionInterval* reverse();
};
class CCDrawNode : public CCNode {
	static CCDrawNode* create();
	void draw();
	ccBlendFunc getBlendFunc();
	void drawPolygon(CCPoint* verts, unsigned int count, const ccColor4F& fillColor, float borderWidth, const ccColor4F& borderColor);
	void clear();
	void setBlendFunc(const ccBlendFunc& blendFunc);
	~CCDrawNode();
	bool init();
	void drawDot(const CCPoint& pos, float radius, const ccColor4F& color);
	void drawSegment(const CCPoint& from, const CCPoint& to, float radius, const ccColor4F& color);
	void listenBackToForeground(CCObject* obj);
};
class CCScriptEngineManager {
	static CCScriptEngineManager* sharedManager();
	static void purgeSharedManager();
	void setScriptEngine(CCScriptEngineProtocol* pScriptEngine);
	CCScriptEngineProtocol* getScriptEngine();
	void removeScriptEngine();
	~CCScriptEngineManager();
};
class CCTMXTiledMap : public CCNodeRGBA {
	static CCTMXTiledMap* create(const string& file);
	float getTileWidth();
	CCTMXMapInfo* getMapInfo();
	void setTileWidth(float var);
	int getMapHeight();
	void setMapWidth(int var);
	CCPoint tmxToNodeSpace(CCPoint p);
	float getTileHeight();
	CCPoint nodeToTMXSpace(CCPoint p);
	~CCTMXTiledMap();
	void setMapInfo(CCTMXMapInfo* var);
	bool isDebugDrawObjects();
	CCTMXLayer* getLayerAt(int index);
	CCTMXLayer* getLayer(const string& name);
	void setTileHeight(float var);
	CCSize getTileSize();
	cbTMXOrientation getOrientation();
	void setDebugDrawObjects(bool var);
	CCDictionary* getTileProperties(int gid);
	bool initWithXMLFile(const string& file);
	void setMapHeight(int var);
	string getProperty(const string& name);
	CCTMXObjectGroup* getObjectGroup(const string& name);
	int getMapWidth();
	CCSize getMapSize();
	string getTileProperty(int gid, const string& name);
};
class CCParticleExplosion : public CCParticleSystemQuad {
	static CCParticleExplosion* create();
	static CCParticleExplosion* createWithTotalParticles(unsigned int numberOfParticles);
	bool init();
	~CCParticleExplosion();
	bool initWithTotalParticles(unsigned int numberOfParticles);
};
class CCDisplayManager : public CCObject {
	bool m_bVisible;
	static CCDisplayManager* create(CCBone* bone);
	CCDecorativeDisplay* getCurrentDecorativeDisplay();
	CCNode* getDisplayRenderNode();
	~CCDisplayManager();
	CCPoint getAnchorPointInPoints();
	void setCurrentDecorativeDisplay(CCDecorativeDisplay* decoDisplay);
	DisplayType getDisplayRenderNodeType();
	void removeDisplay(int index);
	void setForceChangeDisplay(bool var);
	bool init(CCBone* bone);
	CCSize getContentSize();
	CCRect getBoundingBox();
	void addDisplay @ addDisplaypCi(CCNode* display, int index);
	void addDisplay @ addDisplaypCi(CCDisplayData* displayData, int index);
	bool containPoint @ containPointff(float x, float y);
	bool containPoint @ containPointrC(CCPoint& _point);
	void initDisplayList(CCBoneData* boneData);
	void changeDisplayWithIndex(int index, bool force);
	void changeDisplayWithName(const char* name, bool force);
	CCDecorativeDisplay* getDecorativeDisplayByIndex(int index);
	int getCurrentDisplayIndex();
	bool getForceChangeDisplay();
	CCPoint getAnchorPoint();
	CCArray* getDecorativeDisplayList();
	bool isVisible();
	void setVisible(bool visible);
};
class CCActionWatcher : public CCObject {
	static CCActionWatcher* create(CCCallFunc* doneFunc);
	bool isValid();
	CCCallFunc* getDoneFunc();
	void setMustAllDone(bool var);
	void setDoneFunc(CCCallFunc* var);
	void waitAction(CCAction* a);
	void onActionRemoved(CCAction* a);
	void markMustAllDone();
	~CCActionWatcher();
	bool init(CCCallFunc* doneFunc);
	void markValid();
	void clearValid();
	bool isMustAllDone();
	void setValid(bool var);
	void clearMustAllDone();
};
class ScrollView : public Layout, public UIScrollInterface {
	static ScrollView* create();
	static CCObject* createInstance();
	void addChild @ addChildpCi(CCNode* child, int zOrder);
	void addChild @ addChildpC(CCNode* child);
	void addChild @ addChildpCii(CCNode* child, int zOrder, int tag);
	void scrollToTop(float time, bool attenuated);
	void onTouchEnded(CCTouch* touch, CCEvent* unusedEvent);
	void scrollToPercentHorizontal(float percent, float time, bool attenuated);
	string getDescription();
	void removeAllChildren();
	void scrollToBottom(float time, bool attenuated);
	CCArray* getChildren();
	SCROLLVIEW_DIR getDirection();
	CCNode* getChildByTag(int tag);
	void onEnter();
	void setInnerContainerSize(const CCSize& size);
	void scrollToBottomLeft(float time, bool attenuated);
	Layout* getInnerContainer();
	void jumpToBottom();
	Widget* getChildByName(const char* name);
	void setDirection(SCROLLVIEW_DIR dir);
	void scrollToTopLeft(float time, bool attenuated);
	void jumpToTopRight();
	void scrollToPercentBothDirection(const CCPoint& percent, float time, bool attenuated);
	~ScrollView();
	void removeNodeByTag(int tag);
	const CCSize& getInnerContainerSize();
	bool isBounceEnabled();
	void jumpToPercentVertical(float percent);
	void setInertiaScrollEnabled(bool enabled);
	void onTouchMoved(CCTouch* touch, CCEvent* unusedEvent);
	void jumpToTopLeft();
	void jumpToPercentHorizontal(float percent);
	void addNode @ addNodepCi(CCNode* node, int zOrder);
	void addNode @ addNodepC(CCNode* node);
	void addNode @ addNodepCii(CCNode* node, int zOrder, int tag);
	void jumpToBottomRight();
	void update(float dt);
	LayoutType getLayoutType();
	void removeAllChildrenWithCleanup(bool cleanup);
	void onTouchCancelled(CCTouch* touch, CCEvent* unusedEvent);
	CCNode* getNodeByTag(int tag);
	bool isInertiaScrollEnabled();
	void setBounceEnabled(bool enabled);
	void jumpToTop();
	void scrollToLeft(float time, bool attenuated);
	void jumpToPercentBothDirection(const CCPoint& percent);
	void scrollToPercentVertical(float percent, float time, bool attenuated);
	bool onTouchBegan(CCTouch* touch, CCEvent* unusedEvent);
	void scrollToBottomRight(float time, bool attenuated);
	void removeNode(CCNode* node);
	void removeAllNodes();
	void jumpToLeft();
	void scrollToRight(float time, bool attenuated);
	void removeChild @ removeChildpCb(CCNode* child, bool cleaup);
	void removeChild @ removeChildpC(CCNode* child);
	CCArray* getNodes();
	void jumpToBottomLeft();
	CCPoint getTouchEndPoint();
	void setLayoutType(LayoutType type);
	void jumpToRight();
	unsigned int getChildrenCount();
	void scrollToTopRight(float time, bool attenuated);
};
class CCScheduler : public CCObject {
	CCSet* pauseAllTargets();
	void setTimeScale(float fTimeScale);
	void unscheduleUpdateForTarget(const CCObject* pTarget);
	void scheduleUpdateForTarget(CCObject* pTarget, int nPriority, bool bPaused);
	void unscheduleAllWithMinPriority(int nMinPriority);
	bool isTargetPaused(CCObject* pTarget);
	void update(float dt);
	void resumeTarget(CCObject* pTarget);
	~CCScheduler();
	void unscheduleScriptEntry(unsigned int uScheduleScriptEntryID);
	void unscheduleAll();
	void resumeTargets(CCSet* targetsToResume);
	void unscheduleAllForTarget(CCObject* pTarget);
	void pauseTarget(CCObject* pTarget);
	CCSet* pauseAllTargetsWithMinPriority(int nMinPriority);
	unsigned int scheduleScriptFunc(unsigned int nHandler, float fInterval, bool bPaused);
	float getTimeScale();
};
class CCGridBase : public CCObject {
	static CCGridBase* create @ creatercC(const CCSize& gridSize);
	static CCGridBase* create @ creatercCpCb(const CCSize& gridSize, CCTexture2D* texture, bool flipped);
	void setGridSize(const CCSize& gridSize);
	void calculateVertexPoints();
	void afterDraw(CCNode* pTarget);
	void beforeDraw();
	bool isTextureFlipped();
	const CCSize& getGridSize();
	const CCPoint& getStep();
	void set2DProjection();
	~CCGridBase();
	void setStep(const CCPoint& step);
	void setTextureFlipped(bool bFlipped);
	void blit();
	void setActive(bool bActive);
	int getReuseGrid();
	bool initWithSize @ initWithSizercC(const CCSize& gridSize);
	bool initWithSize @ initWithSizercCpCb(const CCSize& gridSize, CCTexture2D* pTexture, bool bFlipped);
	void setReuseGrid(int nReuseGrid);
	bool isActive();
	void reuse();
};
class CCLabelBMFont : public CCSpriteBatchNode, public CCLabelProtocol, public CCRGBAProtocol {
	static void purgeCachedData();
	static CCLabelBMFont* create @ createpccpccfC(const char* str, const char* fntFile, float width, CCTextAlignment alignment);
	static CCLabelBMFont* create @ createpccpccfCC(const char* str, const char* fntFile, float width, CCTextAlignment alignment, CCPoint imageOffset);
	static CCLabelBMFont* create @ createpccpccf(const char* str, const char* fntFile, float width);
	static CCLabelBMFont* create @ createpccpcc(const char* str, const char* fntFile);
	static CCLabelBMFont* create @ create();
	void setAnchorPoint(const CCPoint& var);
	void createFontChars();
	const char* getString();
	CCBMFontConfiguration* getConfiguration();
	void setScale(float scale);
	void setOpacity(unsigned char opacity);
	void setCascadeOpacityEnabled(bool cascadeOpacityEnabled);
	const char* getFntFile();
	void updateLabel();
	void setWidth(float width);
	bool isOpacityModifyRGB();
	bool isCascadeOpacityEnabled();
	void setString @ setStringpccb(const char* newString, bool needUpdateLabel);
	void setString @ setStringpcc(const char* newString);
	bool initWithString(const char* str, const char* fntFile, float width, CCTextAlignment alignment, CCPoint imageOffset);
	void setCascadeColorEnabled(bool cascadeColorEnabled);
	void setOpacityModifyRGB(bool isOpacityModifyRGB);
	~CCLabelBMFont();
	void updateDisplayedOpacity(unsigned char parentOpacity);
	bool init();
	void setFntFile(const char* fntFile);
	unsigned char getOpacity();
	void setLineBreakWithoutSpace(bool breakWithoutSpace);
	void setScaleY(float scaleY);
	void setScaleX(float scaleX);
	const ccColor3B& getColor();
	unsigned char getDisplayedOpacity();
	void setLineKerning(float k);
	bool isCascadeColorEnabled();
	void setColor(const ccColor3B& color);
	void setCString(const char* label);
	const ccColor3B& getDisplayedColor();
	void updateDisplayedColor(const ccColor3B& parentColor);
	void setAlignment(CCTextAlignment alignment);
};
class CCActionTweenDelegate {
	void updateTweenAction(float value, const char* key);
	~CCActionTweenDelegate();
};
class ArmatureMovementDispatcher : public CCObject {
	void animationEvent(CCArmature* armature, MovementEventType movementType, const char* movementID);
	~ArmatureMovementDispatcher();
};
class CCParticleSmoke : public CCParticleSystemQuad {
	static CCParticleSmoke* create();
	static CCParticleSmoke* createWithTotalParticles(unsigned int numberOfParticles);
	bool init();
	~CCParticleSmoke();
	bool initWithTotalParticles(unsigned int numberOfParticles);
};
class CCSprite : public CCNodeRGBA, public CCTextureProtocol {
	static CCSprite* create @ createpcc(const char* pszFileName);
	static CCSprite* create @ create();
	static CCSprite* create @ createpccrcC(const char* pszFileName, const CCRect& rect);
	static CCSprite* createWithTexture @ createWithTexturepCrcC(CCTexture2D* pTexture, const CCRect& rect);
	static CCSprite* createWithTexture @ createWithTexturepC(CCTexture2D* pTexture);
	static CCSprite* createWithSpriteFrameName(const char* pszSpriteFrameName);
	static CCSprite* createWithSpriteFrame(CCSpriteFrame* pSpriteFrame);
	void draw();
	void addChild @ addChildpCi(CCNode* pChild, int zOrder);
	void addChild @ addChildpC(CCNode* pChild);
	void addChild @ addChildpCii(CCNode* pChild, int zOrder, int tag);
	void setTexture(CCTexture2D* texture);
	CCTexture2D* getTexture();
	void setPreDrawFunction(CCCallFuncO* var);
	void setScaleY(float fScaleY);
	void setScale(float fScale);
	void setOpacity(unsigned char opacity);
	void setDisplayFrameWithAnimationName(const char* animationName, int frameIndex);
	void setRotationY(float fRotationY);
	void setAnchorPoint(const CCPoint& anchor);
	CCSpriteFrame* displayFrame();
	void setOpacityModifyRGB(bool modify);
	CCSpriteBatchNode* getBatchNode();
	bool isTextureRectRotated();
	void setShouldUpdateBlendFunc(bool var);
	CCCallFuncO* getPreDrawFunction();
	bool isOpacityModifyRGB();
	bool isShouldUpdateBlendFunc();
	void setTextureRect @ setTextureRectrcCbrcC(const CCRect& rect, bool rotated, const CCSize& untrimmedSize);
	void setTextureRect @ setTextureRectrcC(const CCRect& rect);
	bool isFlipX();
	bool init();
	void setVertexZ(float fVertexZ);
	~CCSprite();
	void updateDisplayedOpacity(unsigned char parentOpacity);
	bool initWithSpriteFrameName(const char* pszSpriteFrameName);
	bool isFrameDisplayed(CCSpriteFrame* pFrame);
	unsigned int getAtlasIndex();
	void setRotation(float fRotation);
	void setDisplayFrame(CCSpriteFrame* pNewFrame);
	const CCPoint& getOffsetPosition();
	void setBatchNode(CCSpriteBatchNode* pobSpriteBatchNode);
	void setRotationX(float fRotationX);
	void setScaleX(float fScaleX);
	bool initWithTexture @ initWithTexturepCrcC(CCTexture2D* pTexture, const CCRect& rect);
	bool initWithTexture @ initWithTexturepC(CCTexture2D* pTexture);
	bool initWithTexture @ initWithTexturepCrcCb(CCTexture2D* pTexture, const CCRect& rect, bool rotated);
	bool isFlipY();
	void setTextureAtlas(CCTextureAtlas* pobTextureAtlas);
	void setFlipY(bool bFlipY);
	void setFlipX(bool bFlipX);
	void removeAllChildrenWithCleanup(bool bCleanup);
	void sortAllChildren();
	void setAtlasIndex(unsigned int uAtlasIndex);
	void markShouldUpdateBlendFunc();
	void clearShouldUpdateBlendFunc();
	void setVertexRect(const CCRect& rect);
	void setDirty(bool bDirty);
	void setPosition(const CCPoint& pos);
	bool isDirty();
	void reorderChild(CCNode* pChild, int zOrder);
	void ignoreAnchorPointForPosition(bool value);
	bool initWithFile @ initWithFilepccrcC(const char* pszFilename, const CCRect& rect);
	bool initWithFile @ initWithFilepcc(const char* pszFilename);
	void setColor(const ccColor3B& color3);
	void setBlendFunc(ccBlendFunc blendFunc);
	const CCRect& getTextureRect();
	CCTextureAtlas* getTextureAtlas();
	ccBlendFunc getBlendFunc();
	bool initWithSpriteFrame(CCSpriteFrame* pSpriteFrame);
	void removeChild(CCNode* pChild, bool bCleanup);
	void updateTransform();
	ccV3F_C4B_T2F_Quad getQuad();
	void updateDisplayedColor(const ccColor3B& parentColor);
	void setSkewX(float sx);
	void setSkewY(float sy);
	void setVisible(bool bVisible);
};
class CCEaseCubicActionOut : public CCActionEase {
	static CCEaseCubicActionOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCProgressHUD : public CCLayerColor {
	static CCProgressHUD* current();
	static void hide();
	static CCProgressHUD* show @ showrcspC(const string& message, CCNode* parent);
	static CCProgressHUD* show @ showrcs(const string& message);
	void keyBackClicked();
	void setPanelColor(const ccColor4B& var);
	bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	bool isForceSquare();
	bool isCancellable();
	void clearCancellable();
	bool initWithMessage(const string& message);
	const ccColor4B& getPanelColor();
	~CCProgressHUD();
	const string& getMessage();
	void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	void setForceSquare(bool var);
	void setIcon(CCSprite* var);
	void draw();
	void setCancellable(bool var);
	void update(float delta);
	const ccColor4B& getDimColor();
	void setDimColor(const ccColor4B& var);
	void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	CCSprite* getIcon();
	void ccTouchCancelled(CCTouch* pTouch, CCEvent* pEvent);
	void setMessage(const string& var);
	void markCancellable();
};
class CCMenuItemToggle : public CCMenuItem {
	static CCMenuItemToggle* create @ createpC(CCMenuItem* item);
	static CCMenuItemToggle* create @ create();
	void setSubItems(CCArray* var);
	bool initWithItem(CCMenuItem* item);
	void setSelectedIndex(unsigned int var);
	void setEnabled(bool var);
	unsigned int getSelectedIndex();
	void addSubItem(CCMenuItem* item);
	void selected();
	~CCMenuItemToggle();
	void activate();
	void unselected();
	CCMenuItem* selectedItem();
	CCArray* getSubItems();
};
class CCLabelAtlas : public CCAtlasNode, public CCLabelProtocol {
	static CCLabelAtlas* create @ createpccpcc(const char* s, const char* fntFile);
	static CCLabelAtlas* create @ createpccpccuiuiui(const char* s, const char* charMapFile, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);
	void updateAtlasValues();
	const char* getString();
	void setString(const char* label);
	bool initWithString @ initWithStringpccpcc(const char* s, const char* fntFile);
	bool initWithString @ initWithStringpccpccuiuiui(const char* s, const char* charMapFile, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);
	bool initWithString @ initWithStringpccpCuiuiui(const char* s, CCTexture2D* texture, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);
	~CCLabelAtlas();
};
class CCBaseData : public CCObject {
	float x;
	float y;
	int zOrder;
	float skewX;
	float skewY;
	float scaleX;
	float scaleY;
	float tweenRotate;
	bool isUseColorInfo;
	int a;
	int r;
	int g;
	int b;
	static CCBaseData* create();
	void setColor(const ccColor4B& color);
	ccColor4B getColor();
	~CCBaseData();
	void copy(const CCBaseData* node);
	void subtract(CCBaseData* from, CCBaseData* to, bool limit);
};
class CCBone : public CCNodeRGBA {
	bool m_bBoneTransformDirty;
	CCAffineTransform m_tWorldTransform;
	float m_fDataVersion;
	ccBlendFunc m_sBlendFunc;
	bool m_bBlendDirty;
	static CCBone* create @ createpcc(const char* name);
	static CCBone* create @ create();
	CCAffineTransform nodeToWorldTransform();
	bool isTransformDirty();
	void updateZOrder();
	void setTransformDirty(bool dirty);
	CCNode* getDisplayRenderNode();
	void addChildBone(CCBone* child);
	bool isBlendDirty();
	~CCBone();
	CCBaseData* getWorldInfo();
	CCTween* getTween();
	CCBone* getParentBone();
	void updateColor();
	void setChildArmature(CCArmature* var);
	string getName();
	void setOpacity(unsigned char opacity);
	DisplayType getDisplayRenderNodeType();
	void removeDisplay(int index);
	void updateDisplayedOpacity(unsigned char parentOpacity);
	bool init @ initpcc(const char* name);
	bool init @ init();
	void setParentBone(CCBone* parent);
	void setZOrder(int zOrder);
	bool getIgnoreMovementBoneData();
	void setIgnoreMovementBoneData(bool var);
	ccBlendFunc getBlendFunc();
	void setName(string var);
	void removeFromParent(bool recursion);
	CCArmature* getChildArmature();
	void update(float delta);
	void setDisplayManager(CCDisplayManager* var);
	CCFrameData* getTweenData();
	void changeDisplayWithIndex(int index, bool force);
	void changeDisplayWithName(const char* name, bool force);
	CCArray* getColliderBodyList();
	void setBoneData(CCBoneData* var);
	void setArmature(CCArmature* var);
	void setBlendDirty(bool dirty);
	void addDisplay @ addDisplaypCi(CCNode* display, int index);
	void addDisplay @ addDisplaypCi(CCDisplayData* displayData, int index);
	void setColor(const ccColor3B& color);
	void removeChildBone(CCBone* bone, bool recursion);
	void setBlendFunc(const ccBlendFunc& blendFunc);
	CCDisplayManager* getDisplayManager();
	CCArmature* getArmature();
	CCAffineTransform nodeToArmatureTransform();
	void updateDisplayedColor(const ccColor3B& parentColor);
	CCBoneData* getBoneData();
};
class CCEaseElasticOut : public CCEaseElastic {
	static CCEaseElasticOut* create @ createpC(CCActionInterval* pAction);
	static CCEaseElasticOut* create @ createpCf(CCActionInterval* pAction, float fPeriod);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCData : public CCObject {
	static CCData* create();
	static CCData* createWithBytes(unsigned char* bytes, unsigned long size);
	static CCData* createWithData(CCData* data);
	void setBytes(unsigned char* var);
	void appendBytes(unsigned char* bytes, unsigned long size);
	~CCData();
	unsigned long getSize();
	void appendData(CCData* data);
	void setSize(unsigned long var);
	unsigned char* getBytes();
};
class CCGrid3DAction : public CCGridAction {
	static CCGrid3DAction* create(float duration, const CCSize& gridSize);
	void setVertex(const CCPoint& position, const ccVertex3F& vertex);
	CCGridBase* getGrid();
	ccVertex3F vertex(const CCPoint& position);
	ccVertex3F originalVertex(const CCPoint& position);
};
class CCLayerRGBA : public CCLayer, public CCRGBAProtocol {
	static CCLayerRGBA* create();
	void updateDisplayedColor(const ccColor3B& parentColor);
	void setColor(const ccColor3B& color);
	bool isCascadeOpacityEnabled();
	const ccColor3B& getColor();
	unsigned char getDisplayedOpacity();
	void setCascadeColorEnabled(bool cascadeColorEnabled);
	void setOpacity(unsigned char opacity);
	~CCLayerRGBA();
	void setCascadeOpacityEnabled(bool cascadeOpacityEnabled);
	void updateDisplayedOpacity(unsigned char parentOpacity);
	bool init();
	void setOpacityModifyRGB(bool bValue);
	unsigned char getOpacity();
	bool isOpacityModifyRGB();
	bool isCascadeColorEnabled();
	const ccColor3B& getDisplayedColor();
};
class CCSplitRows : public CCTiledGrid3DAction {
	static CCSplitRows* create(float duration, unsigned int nRows);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, unsigned int nRows);
	void update(float time);
};
class CheckBox : public Widget {
	static CheckBox* create();
	static CCObject* createInstance();
	void setAnchorPoint(const CCPoint& pt);
	bool getSelectedState();
	void loadTextureBackGroundSelected(const char* backGroundSelected, TextureResType texType);
	void loadTextureBackGroundDisabled(const char* backGroundDisabled, TextureResType texType);
	string getDescription();
	CCNode* getVirtualRenderer();
	void loadTextureFrontCross(const char* cross, TextureResType texType);
	const CCSize& getContentSize();
	void loadTextures(const char* backGround, const char* backGroundSelected, const char* cross, const char* backGroundDisabled, const char* frontCrossDisabled, TextureResType texType);
	void onTouchEnded(CCTouch* touch, CCEvent* unused_event);
	~CheckBox();
	void loadTextureBackGround(const char* backGround, TextureResType type);
	void setSelectedState(bool selected);
	void loadTextureFrontCrossDisabled(const char* frontCrossDisabled, TextureResType texType);
};
class CCRipple3D : public CCGrid3DAction {
	static CCRipple3D* create(float duration, const CCSize& gridSize, const CCPoint& position, float radius, unsigned int waves, float amplitude);
	void setAmplitudeRate(float fAmplitudeRate);
	bool initWithDuration(float duration, const CCSize& gridSize, const CCPoint& position, float radius, unsigned int waves, float amplitude);
	void update(float time);
	float getAmplitudeRate();
	void setAmplitude(float fAmplitude);
	float getAmplitude();
	void setPosition(const CCPoint& position);
	const CCPoint& getPosition();
	CCObject* copyWithZone(CCZone* pZone);
};
class BaseTriggerAction : public CCObject {
	void removeAll();
	bool init();
	void serialize @ serializepCps(CocoLoader* pCocoLoader, stExpCocoNode* pCocoNode);
	void done();
	~BaseTriggerAction();
};
class CCRotateBy : public CCActionInterval {
	static CCRotateBy* create @ createfff(float fDuration, float fDeltaAngleX, float fDeltaAngleY);
	static CCRotateBy* create @ createff(float fDuration, float fDeltaAngle);
	void startWithTarget(CCNode* pTarget);
	CCActionInterval* reverse();
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration @ initWithDurationfff(float fDuration, float fDeltaAngleX, float fDeltaAngleY);
	bool initWithDuration @ initWithDurationff(float fDuration, float fDeltaAngle);
	void update(float time);
};
class CCContourData : public CCObject {
	CCArray vertexList;
	static CCContourData* create();
	bool init();
	~CCContourData();
	void addVertex(CCPoint* vertex);
};
class CCActionEase : public CCActionInterval {
	static CCActionEase* create(CCActionInterval* pAction);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	void stop();
	void update(float time);
	~CCActionEase();
	bool initWithAction(CCActionInterval* pAction);
	CCActionInterval* getInnerAction();
	CCActionInterval* reverse();
};
class CCCallFuncO : public CCCallFunc, public TypeInfo {
	CCObject* getObject();
	void execute();
	void setObject(CCObject* pObj);
	CCObject* copyWithZone(CCZone* pZone);
	~CCCallFuncO();
	long getClassTypeInfo();
};
class CCCallFuncN : public CCCallFunc, public TypeInfo {
	static CCCallFuncN* create(int nHandler);
	long getClassTypeInfo();
	void execute();
	~CCCallFuncN();
	CCObject* copyWithZone(CCZone* pZone);
};
class CCMD5 {
	static const char* md5 @ md5pcvul(const void* data, unsigned long len);
	static string md5 @ md5pcc(const char* s);
};
class LinearLayoutParameter : public LayoutParameter {
	static LinearLayoutParameter* create();
	void setGravity(LinearGravity gravity);
	~LinearLayoutParameter();
	LayoutParameter* createCloneInstance();
	void copyProperties(LayoutParameter* model);
	LinearGravity getGravity();
};
class CCAnimate : public CCActionInterval {
	static CCAnimate* create(CCAnimation* pAnimation);
	void startWithTarget(CCNode* pTarget);
	CCAnimation* getAnimation();
	CCObject* copyWithZone(CCZone* pZone);
	void stop();
	void update(float t);
	~CCAnimate();
	bool initWithAnimation(CCAnimation* pAnimation);
	void setAnimation(CCAnimation* var);
	CCActionInterval* reverse();
};
class CCMWManager : public CCObject {
	static CCMWManager* getInstance();
	CCMWFileData* load(const char* path);
	CCMWFileData* getAnimationFileData(const string& path);
	void releaseAllAnimationFileData();
	CCAFCAnimation* getAnimationData(CCMWFileData* fileData, int animIndex, CCAFCClipMapping* mapping);
	~CCMWManager();
};
class CCRect {
	CCPoint origin;
	CCSize size;
	float getMaxY();
	float getMaxX();
	bool equals(const CCRect& rect);
	float getMinY();
	float getMinX();
	float getMidY();
	float getMidX();
	bool intersectsRect(const CCRect& rect);
	CCRect(float x, float y, float width, float height);
	CCRect();
	CCRect(const CCRect& other);
	bool containsPoint(const CCPoint& point);
	void setRect(float x, float y, float width, float height);
};
class CCJSONObject : public CCObject {
	static CCJSONObject* create @ createpccul(const char* json, unsigned long length);
	static CCJSONObject* create @ create();
	static CCJSONObject* create @ creatercs(const string& path);
	void addDouble(const char* key, double d);
	long optLong @ optLongil(int index, long def);
	long optLong @ optLongpccl(const char* key, long def);
	const char* keyAt(int index);
	CCJSONObject* optJSONObject @ optJSONObjecti(int index);
	CCJSONObject* optJSONObject @ optJSONObjectpcc(const char* key);
	void addInt(const char* key, int i);
	void addBool(const char* key, bool b);
	void addArray(const char* key, CCJSONArray* ja);
	bool optBool @ optBoolib(int index, bool def);
	bool optBool @ optBoolpccb(const char* key, bool def);
	int getLength();
	~CCJSONObject();
	string toString();
	void addNull(const char* key);
	void addString(const char* key, const char* s);
	void addObject(const char* key, CCJSONObject* jo);
	void addLong(const char* key, long l);
	CCJSONArray* optJSONArray @ optJSONArrayi(int index);
	CCJSONArray* optJSONArray @ optJSONArraypcc(const char* key);
	float optFloat @ optFloatif(int index, float def);
	float optFloat @ optFloatpccf(const char* key, float def);
	void addFloat(const char* key, float f);
	string optString @ optStringipcc(int index, const char* def);
	string optString @ optStringpccpcc(const char* key, const char* def);
	double optDouble @ optDoubleid(int index, double def);
	double optDouble @ optDoublepccd(const char* key, double def);
	int optInt @ optIntii(int index, int def);
	int optInt @ optIntpcci(const char* key, int def);
	void output(CCAssetOutputStream* aos, int level);
};
class CCScriptEngineProtocol {
	int executeNotificationEvent(CCNotificationCenter* pNotificationCenter, const char* pszName);
	int executeLayerTouchEvent(CCLayer* pLayer, int eventType, CCTouch* pTouch);
	int executeMenuItemEvent(CCMenuItem* pMenuItem);
	int executeEventWithArgs(int nHandler, CCArray* pArgs);
	int executeAccelerometerEvent(CCLayer* pLayer, CCAcceleration* pAccelerationValue);
	int executeLayerTouchesEvent(CCLayer* pLayer, int eventType, CCSet* pTouches);
	ccScriptType getScriptType();
	void removeScriptObjectByCCObject(CCObject* pObj);
	int executeScriptFile(const char* filename);
	int executeCallFuncActionEvent(CCCallFunc* pAction, CCObject* pTarget);
	~CCScriptEngineProtocol();
	int executeGlobalFunction(const char* functionName);
	int executeString(const char* codes);
	bool handleAssert(const char* msg);
	int executeSchedule(int nHandler, float dt, CCNode* pNode);
	int executeEvent(int nHandler, const char* pEventName, CCObject* pEventSource, const char* pEventSourceClassName);
	bool parseConfig(ConfigType type, const string& str);
	int executeNodeEvent(CCNode* pNode, int nAction);
	void removeScriptHandler(int nHandler);
	int executeLayerKeypadEvent(CCLayer* pLayer, int eventType);
	int reallocateScriptHandler(int nHandler);
	enum ConfigType {
		NONE,
		COCOSTUDIO
	};
};
class CCEaseOut : public CCEaseRateAction {
	static CCEaseOut* create(CCActionInterval* pAction, float fRate);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCTintTo : public CCActionInterval {
	static CCTintTo* create(float duration, unsigned char red, unsigned char green, unsigned char blue);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, unsigned char red, unsigned char green, unsigned char blue);
	void update(float time);
};
class CCParticleGalaxy : public CCParticleSystemQuad {
	static CCParticleGalaxy* create();
	static CCParticleGalaxy* createWithTotalParticles(unsigned int numberOfParticles);
	bool init();
	~CCParticleGalaxy();
	bool initWithTotalParticles(unsigned int numberOfParticles);
};
class CCEaseExponentialIn : public CCActionEase {
	static CCEaseExponentialIn* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCTextureAtlas : public CCObject {
	static CCTextureAtlas* create(const char* file, unsigned int capacity);
	static CCTextureAtlas* createWithTexture(CCTexture2D* texture, unsigned int capacity);
	void setTexture(CCTexture2D* var);
	void updateQuad(ccV3F_C4B_T2F_Quad* quad, unsigned int index);
	CCTexture2D* getTexture();
	void setQuads(ccV3F_C4B_T2F_Quad* var);
	void moveQuadsFromIndex @ moveQuadsFromIndexuiui(unsigned int index, unsigned int newIndex);
	void moveQuadsFromIndex @ moveQuadsFromIndexuiuiui(unsigned int oldIndex, unsigned int amount, unsigned int newIndex);
	unsigned int getTotalQuads();
	void drawQuads();
	void fillWithEmptyQuadsFromIndex(unsigned int index, unsigned int amount);
	~CCTextureAtlas();
	unsigned int getCapacity();
	void listenBackToForeground(CCObject* obj);
	bool initWithTexture(CCTexture2D* texture, unsigned int capacity);
	const char* description();
	void removeQuadsAtIndex(unsigned int index, unsigned int amount);
	void insertQuad(ccV3F_C4B_T2F_Quad* quad, unsigned int index);
	void drawNumberOfQuads @ drawNumberOfQuadsuiui(unsigned int n, unsigned int start);
	void drawNumberOfQuads @ drawNumberOfQuadsui(unsigned int n);
	void setDirty(bool bDirty);
	bool isDirty();
	void removeAllQuads();
	bool initWithFile(const char* file, unsigned int capacity);
	ccV3F_C4B_T2F_Quad* getQuads();
	bool resizeCapacity(unsigned int n);
	void increaseTotalQuadsWith(unsigned int amount);
	void insertQuads(ccV3F_C4B_T2F_Quad* quads, unsigned int index, unsigned int amount);
	void insertQuadFromIndex(unsigned int fromIndex, unsigned int newIndex);
	void removeQuadAtIndex(unsigned int index);
};
class CCTMXTileSetInfo : public CCObject {
	static CCTMXTileSetInfo* create();
	float getTileWidth();
	void setSourceImagePath(string var);
	void setTexture(CCTexture2D* var);
	CCTexture2D* getTexture();
	void setTileWidth(float var);
	void setSpacing(float var);
	CCRect getRect(int gid);
	string getName();
	float getTileHeight();
	~CCTMXTileSetInfo();
	void setImageWidth(float var);
	void setFirstGid(int var);
	float getImageWidth();
	void setName(string var);
	float getSpacing();
	float getMargin();
	void setImageHeight(float var);
	void setMargin(float var);
	int getFirstGid();
	void setTileHeight(float var);
	string getSourceImagePath();
	float getImageHeight();
};
class CCUUID {
	static string generate(bool noHyphen);
};
class CCUtils {
	static string trim(const string& s);
	static bool createIntermediateFolders(const string& path);
	static void openUrl(const string& url);
	static int getUTF8Bytes(unsigned char c);
	static void removeChar(string& s, char c);
	static string joinFloat(const CCArray& a, char sep);
	static string deletePathExtension(const string& path);
	static CCArray* getChildrenByTag(CCNode* parent, int tag);
	static CCPoint getOrigin(CCNode* node);
	static string joinInt(const CCArray& a, char sep);
	static string appendPathComponent(const string& path, const string& component);
	static CCPoint getPoint @ getPointpCC(CCNode* node, CCPoint anchor);
	static CCPoint getPoint @ getPointpCff(CCNode* node, float xpercent, float ypercent);
	static string replace(string& s, const string& c, const string& sub);
	static string arrayToString(const CCArray& array);
	static CCArray& boolComponentsOfString(const string& s, char sep);
	static double pfloor(double x, int precision);
	static string externalize(const string& path);
	static string decodeHtmlEntities(const string& src);
	static bool verifySignature(void* validSign, unsigned long len);
	static string getPinyin(const string& s);
	static long long currentTimeMillis();
	static bool deleteFile(const string& path);
	static string makeScreenshot(CCNode* root, const string& path, bool needStencil);
	static CCRect getCenterRect @ getCenterRectpC(CCSpriteFrame* f);
	static CCRect getCenterRect @ getCenterRectrcs(const string& frameName);
	static bool startsWith(const string& s, const string& sub);
	static string getMacAddress();
	static int getSystemVersionInt();
	static CCArray& intComponentsOfString(const string& s, char sep);
	static string getAppVersion();
	static int strlen8(const char* s);
	static long long getAvailableStorageSize();
	static string getDeviceType();
	static float lerp(float a, float b, float p);
	static bool createFolder(const string& path);
	static int getNumDigits(int num);
	static ccColorHSV ccc32hsv(ccColor3B c);
	static CCRect combine(const CCRect& r1, const CCRect& r2);
	static CCSize ccsFromString(const string& s);
	static CCPoint getLocalPoint @ getLocalPointpCC(CCNode* node, CCPoint anchor);
	static CCPoint getLocalPoint @ getLocalPointpCff(CCNode* node, float xpercent, float ypercent);
	static CCScene* getScene(CCNode* n);
	static bool testSegmentAABB(CCPoint p0, CCPoint p1, ccAABB b);
	static CCArray& arrayFromString(const string& s);
	static bool hasExternalStorage();
	static double pceil(double x, int precision);
	static void toLowercase(string& s);
	static string lastPathComponent(const string& path);
	static string joinString(const CCArray& a, char sep);
	static string getPackageName();
	static string getParentPath(const string& path);
	static double pround(double x, int precision);
	static void removeChildrenByTag(CCNode* parent, int tag);
	static string joinBool(const CCArray& a, char sep);
	static CCRect ccrFromString(const string& s);
	static CCPoint getCenter(CCNode* node);
	static CCRect getBoundingBoxInWorldSpace(CCNode* node);
	static string getInternalStoragePath();
	static CCArray& componentsOfString(const string& s, char sep);
	static const char* copy @ copypcciul(const char* src, int start, unsigned long len);
	static const char* copy @ copypcc(const char* src);
	static void replaceChar(string& s, char c, char sub);
	static bool containsRect(const CCRect& r1, const CCRect& r2);
	static int binarySearch(int* a, unsigned long len, int key);
	static unsigned long nextPOT(unsigned long value);
	static CCPoint ccpFromString(const string& s);
	static string getExternalOrFullPath(const string& path);
	static int lastSlashIndex(string path);
	static void setOpacityRecursively(CCNode* node, int o);
	static string deleteLastPathComponent(const string& path);
	static bool isPathExistent(const string& path);
	static CCPoint getLocalCenter(CCNode* node);
	static bool isDebugSignature();
	static bool endsWith(const string& s, const string& sub);
	static int lastDotIndex(const string& path);
	static string getPathExtension(const string& path);
	static void openAppInStore(const string& appId);
	static CCArray& floatComponentsOfString(const string& s, char sep);
	static ccColor3B hsv2ccc3(ccColorHSV c);
	static int getCpuHz();
	static void showSystemConfirmDialog(const char* title, const char* msg, const char* positiveButton, const char* negativeButton, CCCallFunc* onOK, CCCallFunc* onCancel);
};
class CCEaseBounceIn : public CCEaseBounce {
	static CCEaseBounceIn* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCControlStepper : public CCControl {
	double m_dValue;
	bool m_bContinuous;
	bool m_bAutorepeat;
	bool m_bWraps;
	double m_dMinimumValue;
	double m_dMaximumValue;
	double m_dStepValue;
	bool m_bTouchInsideFlag;
	CCControlStepperPart m_eTouchedPart;
	int m_nAutorepeatCount;
	static CCControlStepper* create(CCSprite* minusSprite, CCSprite* plusSprite);
	void setMinusSprite(CCSprite* var);
	bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	CCLabelTTF* getMinusLabel();
	void setWraps(bool wraps);
	void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	bool isContinuous();
	CCSprite* getMinusSprite();
	void updateLayoutUsingTouchLocation(CCPoint location);
	void setValueWithSendingEvent(double value, bool send);
	~CCControlStepper();
	CCLabelTTF* getPlusLabel();
	void stopAutorepeat();
	void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	void setMaximumValue(double maximumValue);
	void setPlusSprite(CCSprite* var);
	void setMinusLabel(CCLabelTTF* var);
	void setValue(double value);
	void setStepValue(double stepValue);
	CCSprite* getPlusSprite();
	void update(float dt);
	void setMinimumValue(double minimumValue);
	void startAutorepeat();
	bool initWithMinusSpriteAndPlusSprite(CCSprite* minusSprite, CCSprite* plusSprite);
	double getValue();
	void setPlusLabel(CCLabelTTF* var);
};
class Layout : public Widget {
	static Layout* create();
	static CCObject* createInstance();
	void setBackGroundColorVector(const CCPoint& vector);
	void addChild @ addChildpCi(CCNode* child, int zOrder);
	void addChild @ addChildpC(CCNode* child);
	void addChild @ addChildpCii(CCNode* child, int zOrder, int tag);
	void onEnter();
	void setClippingType(LayoutClippingType type);
	void setBackGroundColorType(LayoutBackGroundColorType type);
	void setBackGroundImageColor(const ccColor3B& color);
	const CCPoint& getBackGroundColorVector();
	void removeAllChildren();
	LayoutClippingType getClippingType();
	void removeBackGroundImage();
	unsigned char getBackGroundColorOpacity();
	bool isClippingEnabled();
	void setBackGroundImageOpacity(unsigned char opacity);
	void setBackGroundImage(const char* fileName, TextureResType texType);
	void setBackGroundColor @ setBackGroundColorrccrcc(const ccColor3B& startColor, const ccColor3B& endColor);
	void setBackGroundColor @ setBackGroundColorrcc(const ccColor3B& color);
	void visit();
	void requestDoLayout();
	~Layout();
	const CCRect& getBackGroundImageCapInsets();
	const ccColor3B& getBackGroundColor();
	void setClippingEnabled(bool enabled);
	string getDescription();
	const ccColor3B& getBackGroundImageColor();
	bool isBackGroundImageScale9Enabled();
	LayoutBackGroundColorType getBackGroundColorType();
	const ccColor3B& getBackGroundEndColor();
	void setBackGroundColorOpacity(unsigned char opacity);
	unsigned char getBackGroundImageOpacity();
	void removeAllChildrenWithCleanup(bool cleanup);
	void sortAllChildren();
	void setBackGroundImageCapInsets(const CCRect& capInsets);
	const CCSize& getBackGroundImageTextureSize();
	void onExit();
	LayoutType getLayoutType();
	const ccColor3B& getBackGroundStartColor();
	bool hitTest(const CCPoint& pt);
	void removeChild @ removeChildpCb(CCNode* widget, bool cleanup);
	void removeChild @ removeChildpC(CCNode* child);
	void setBackGroundImageScale9Enabled(bool enabled);
	void setLayoutType(LayoutType type);
};
class CCTransitionEaseScene {
	CCActionInterval* easeActionWithAction(CCActionInterval* action);
};
class CCTouchScriptHandlerEntry : public CCScriptHandlerEntry {
	static CCTouchScriptHandlerEntry* create(int nHandler, bool bIsMultiTouches, int nPriority, bool bSwallowsTouches);
	bool isMultiTouches();
	int getPriority();
	bool getSwallowsTouches();
	~CCTouchScriptHandlerEntry();
};
class CCString : public CCObject {
	string m_sString;
	static CCString* create(const string& str);
	static CCString* createWithContentsOfFile(const char* pszFileName);
	static CCString* createWithData(const unsigned char* pData, unsigned long nLen);
	unsigned int uintValue();
	int compare(const char* );
	CCObject* copyWithZone(CCZone* pZone);
	bool boolValue();
	float floatValue();
	double doubleValue();
	~CCString();
	int intValue();
	bool isEqual(const CCObject* pObject);
	unsigned int length();
	void acceptVisitor(CCDataVisitor& visitor);
	const char* getCString();
};
class CCFadeTo : public CCActionInterval {
	static CCFadeTo* create(float duration, unsigned char opacity);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float duration, unsigned char opacity);
	void update(float time);
};
class CCEaseExponentialOut : public CCActionEase {
	static CCEaseExponentialOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCAFCSpriteCallback {
	void onAFCSpriteAnimationFrameChanged(CCAFCSprite* sprite);
	void onAFCSpriteAnimationEnded(CCAFCSprite* sprite);
};
class CCNotificationCenter : public CCObject {
	static CCNotificationCenter* sharedNotificationCenter();
	static void purgeNotificationCenter();
	void postNotification @ postNotificationpccpC(const char* name, CCObject* object);
	void postNotification @ postNotificationpcc(const char* name);
	void removeObserver(CCObject* target, const char* name);
	int getObserverHandlerByName(const char* name);
	int removeAllObservers(CCObject* target);
	~CCNotificationCenter();
	void unregisterScriptObserver(CCObject* target, const char* name);
	int getScriptHandler();
	void registerScriptObserver(CCObject* target, int handler, const char* name);
};
class CCGradientSprite : public CCSprite {
	static CCGradientSprite* create @ createpcc(const char* pszFileName);
	static CCGradientSprite* create @ create();
	static CCGradientSprite* create @ createpccrcC(const char* pszFileName, const CCRect& rect);
	static CCGradientSprite* createWithTexture @ createWithTexturepCrcC(CCTexture2D* pTexture, const CCRect& rect);
	static CCGradientSprite* createWithTexture @ createWithTexturepC(CCTexture2D* pTexture);
	static CCGradientSprite* createWithSpriteFrameName(const char* pszSpriteFrameName);
	static CCGradientSprite* createWithSpriteFrame(CCSpriteFrame* pSpriteFrame);
	const ccColor3B& getStartColor();
	void setCompressedInterpolation(bool var);
	unsigned char getEndOpacity();
	void setColor @ setColorrccrccrcC(const ccColor4B& start, const ccColor4B& end, const CCPoint& v);
	void setColor @ setColorrcc(const ccColor3B& color3);
	void setOpacity(unsigned char opacity);
	bool getCompressedInterpolation();
	unsigned char getStartOpacity();
	void setStartOpacity(unsigned char var);
	const ccColor3B& getEndColor();
	bool isCompressedInterpolation();
	void setOpacityModifyRGB(bool modify);
	~CCGradientSprite();
	const CCPoint& getVector();
	void updateDisplayedOpacity(unsigned char parentOpacity);
	void setEndColor(const ccColor3B& var);
	void updateDisplayedColor(const ccColor3B& parentColor);
	void setEndOpacity(unsigned char var);
	void setStartColor(const ccColor3B& var);
	void setVector(const CCPoint& var);
};
class CCSequence : public CCActionInterval {
	static CCSequence* create(CCArray* arrayOfActions);
	static CCSequence* createWithTwoActions(CCFiniteTimeAction* pActionOne, CCFiniteTimeAction* pActionTwo);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	void stop();
	void update(float t);
	bool initWithTwoActions(CCFiniteTimeAction* pActionOne, CCFiniteTimeAction* pActionTwo);
	~CCSequence();
	CCActionInterval* reverse();
};
class CCCopying {
	CCObject* copyWithZone(CCZone* pZone);
};
class Slider : public Widget {
	static Slider* create();
	static CCObject* createInstance();
	void setPercent(int percent);
	CCNode* getVirtualRenderer();
	void onTouchEnded(CCTouch* touch, CCEvent* unused_event);
	void loadSlidBallTextureNormal(const char* normal, TextureResType texType);
	void loadProgressBarTexture(const char* fileName, TextureResType texType);
	string getDescription();
	void setScale9Enabled(bool able);
	const CCRect& getCapInsetBarRenderer();
	void ignoreContentAdaptWithSize(bool ignore);
	void loadSlidBallTextures(const char* normal, const char* pressed, const char* disabled, TextureResType texType);
	~Slider();
	const CCSize& getContentSize();
	void onTouchMoved(CCTouch* touch, CCEvent* unused_event);
	void loadBarTexture(const char* fileName, TextureResType texType);
	void onTouchCancelled(CCTouch* touch, CCEvent* unused_event);
	bool onTouchBegan(CCTouch* touch, CCEvent* unused_event);
	void loadSlidBallTexturePressed(const char* pressed, TextureResType texType);
	bool isScale9Enabled();
	void setCapInsetProgressBarRebderer(const CCRect& capInsets);
	void setCapInsetsBarRenderer(const CCRect& capInsets);
	void setCapInsets(const CCRect& capInsets);
	void loadSlidBallTextureDisabled(const char* disabled, TextureResType texType);
	int getPercent();
	const CCRect& getCapInsetProgressBarRebderer();
};
class CCComAttribute : public CCComponent {
	static CCComAttribute* create();
	static CCObject* createInstance();
	float getFloat(const char* key, float def);
	bool getBool(const char* key, bool def);
	void setCString(const char* key, const char* value);
	void setFloat(const char* key, float value);
	const char* getCString(const char* key, const char* def);
	bool serialize(void* r);
	void setInt(const char* key, int value);
	~CCComAttribute();
	bool parse(const string& jsonPath);
	int getInt(const char* key, int def);
	bool init();
	void setBool(const char* key, bool value);
};
class CCMenuItemImage : public CCMenuItemSprite {
	static CCMenuItemImage* create @ createpccpccpcc(const char* normalImage, const char* selectedImage, const char* disabledImage);
	static CCMenuItemImage* create @ createpccpcc(const char* normalImage, const char* selectedImage);
	static CCMenuItemImage* create @ create();
	void setDisabledSpriteFrame(CCSpriteFrame* frame);
	void setSelectedSpriteFrame(CCSpriteFrame* frame);
	void setNormalSpriteFrame(CCSpriteFrame* frame);
	~CCMenuItemImage();
	bool init();
};
class CCEaseQuinticActionInOut : public CCActionEase {
	static CCEaseQuinticActionInOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class CCEaseBackOut : public CCActionEase {
	static CCEaseBackOut* create(CCActionInterval* pAction);
	CCObject* copyWithZone(CCZone* pZone);
	void update(float time);
	CCActionInterval* reverse();
};
class ActionObject : public CCObject {
	void setCurrentTime(float fTime);
	void pause();
	void setUnitTime(float fTime);
	void setName(const char* name);
	float getTotalTime();
	void simulationActionUpdate(float dt);
	const char* getName();
	void stop();
	void play @ playpC(CCCallFunc* func);
	void play @ play();
	float getCurrentTime();
	~ActionObject();
	bool getLoop();
	void addActionNode(ActionNode* node);
	float getUnitTime();
	bool isPlaying();
	void updateToFrameByTime(float fTime);
	void setLoop(bool bLoop);
	void removeActionNode(ActionNode* node);
};
class CCCalendar : public CCObject {
	static CCCalendar* sharedCalendar();
	int getWeekday();
	int getHour();
	int getSecond();
	float getTime();
	~CCCalendar();
	void setTime(float time);
	void setNow();
	int getYear();
	int getDay();
	int getMinute();
	int getMonth();
};
class CCStandardTouchHandler : public CCTouchHandler {
	static CCStandardTouchHandler* handlerWithDelegate(CCTouchDelegate* pDelegate, int nPriority);
	bool initWithDelegate(CCTouchDelegate* pDelegate, int nPriority);
};
class CCByteBuffer : public CCObject {
	static CCByteBuffer* create @ createul(unsigned long res);
	static CCByteBuffer* create @ create();
	unsigned long available();
	void compact();
	void setReadPos(unsigned long p);
	void readPascalString(string& dest);
	void revoke(unsigned long len);
	void read @ readrs(string& dest);
	unsigned long read @ readpucul(unsigned char* buffer, unsigned long len);
	void skip(unsigned long len);
	void clear();
	void writeCString(const string& value);
	~CCByteBuffer();
	void write @ writercs(const string& value);
	void write @ writepcucul(const unsigned char* data, unsigned long size);
	void readCString(string& dest);
	unsigned long getReadPos();
	void writeLine(const string& value);
	void readLine(string& dest);
	const unsigned char* getBuffer();
	void setWritePos(unsigned long p);
	void writePascalString(const string& value);
};
class CCActionInterval : public CCFiniteTimeAction {
	static CCActionInterval* create(float d);
	void startWithTarget(CCNode* pTarget);
	CCObject* copyWithZone(CCZone* pZone);
	bool initWithDuration(float d);
	void setAmplitudeRate(float amp);
	float getAmplitudeRate();
	void step(float dt);
	float getElapsed();
	bool isDone();
	CCActionInterval* reverse();
};
class CCBatchNode : public CCNode {
	static CCBatchNode* create();
	void addChild @ addChildpCi(CCNode* pChild, int zOrder);
	void addChild @ addChildpC(CCNode* pChild);
	void addChild @ addChildpCii(CCNode* pChild, int zOrder, int tag);
	void draw();
	CCTextureAtlas* getTexureAtlasWithTexture(CCTexture2D* texture);
	void visit();
	~CCBatchNode();
	void removeChild(CCNode* child, bool cleanup);
	bool init();
};
class CCIMEDelegate {
	bool attachWithIME();
	bool detachWithIME();
	~CCIMEDelegate();
};
class CCMenuItemLabel : public CCMenuItem {
	static CCMenuItemLabel* create(CCNode* label);
	void setEnabled(bool enabled);
	void setLabel(CCNode* var);
	void activate();
	const ccColor3B& getDisabledColor();
	void setString(const char* label);
	void selected();
	~CCMenuItemLabel();
	void setDisabledColor(const ccColor3B& var);
	CCNode* getLabel();
	void unselected();
};
class LabelAtlas : public Widget {
	static LabelAtlas* create();
	static CCObject* createInstance();
	void setAnchorPoint(const CCPoint& pt);
	CCNode* getVirtualRenderer();
	const char* getStringValue();
	string getDescription();
	~LabelAtlas();
	const CCSize& getContentSize();
	void setProperty(const string& stringValue, const string& charMapFile, int itemWidth, int itemHeight, const string& startCharMap);
	void setStringValue(const string& value);
};
class CCKeypadDispatcher : public CCObject {
	void forceRemoveDelegate(CCKeypadDelegate* pDelegate);
	bool dispatchKeypadMSG(ccKeypadMSGType nMsgType);
	void forceAddDelegate(CCKeypadDelegate* pDelegate);
	~CCKeypadDispatcher();
	void addDelegate(CCKeypadDelegate* pDelegate);
	void removeDelegate(CCKeypadDelegate* pDelegate);
};
enum EditBoxInputMode {
	kEditBoxInputModeAny,
	kEditBoxInputModeEmailAddr,
	kEditBoxInputModeNumeric,
	kEditBoxInputModePhoneNumber,
	kEditBoxInputModeUrl,
	kEditBoxInputModeDecimal,
	kEditBoxInputModeSingleLine
};
enum InnerActionType {
	LoopAction,
	NoLoopAction,
	SingleFrame
};
enum KeyboardReturnType {
	kKeyboardReturnTypeDefault,
	kKeyboardReturnTypeDone,
	kKeyboardReturnTypeSend,
	kKeyboardReturnTypeSearch,
	kKeyboardReturnTypeGo
};
enum ccScriptType {
	kScriptTypeNone,
	kScriptTypeLua,
	kScriptTypeJavascript
};
enum ResolutionPolicy {
	kResolutionExactFit,
	kResolutionNoBorder,
	kResolutionShowAll,
	kResolutionFixedHeight,
	kResolutionFixedWidth,
	kResolutionUnKnown
};
typedef enum {
	kCCImageFormatJPEG,
	kCCImageFormatPNG
} tCCImageFormat;
enum CCTweenType {
	CUSTOM_EASING,
	Linear,
	Sine_EaseIn,
	Sine_EaseOut,
	Sine_EaseInOut,
	Quad_EaseIn,
	Quad_EaseOut,
	Quad_EaseInOut,
	Cubic_EaseIn,
	Cubic_EaseOut,
	Cubic_EaseInOut,
	Quart_EaseIn,
	Quart_EaseOut,
	Quart_EaseInOut,
	Quint_EaseIn,
	Quint_EaseOut,
	Quint_EaseInOut,
	Expo_EaseIn,
	Expo_EaseOut,
	Expo_EaseInOut,
	Circ_EaseIn,
	Circ_EaseOut,
	Circ_EaseInOut,
	Elastic_EaseIn,
	Elastic_EaseOut,
	Elastic_EaseInOut,
	Back_EaseIn,
	Back_EaseOut,
	Back_EaseInOut,
	Bounce_EaseIn,
	Bounce_EaseOut,
	Bounce_EaseInOut,
	TWEEN_EASING_MAX
};
typedef enum {
	LISTVIEW_GRAVITY_LEFT,
	LISTVIEW_GRAVITY_RIGHT,
	LISTVIEW_GRAVITY_CENTER_HORIZONTAL,
	LISTVIEW_GRAVITY_TOP,
	LISTVIEW_GRAVITY_BOTTOM,
	LISTVIEW_GRAVITY_CENTER_VERTICAL
} ListViewGravity;
typedef enum {
	kCCScrollViewDirectionNone,
	kCCScrollViewDirectionHorizontal,
	kCCScrollViewDirectionVertical,
	kCCScrollViewDirectionBoth
} CCScrollViewDirection;
typedef enum {
	kTypeBackClicked,
	kTypeMenuClicked
} ccKeypadMSGType;
enum TargetPlatform {
	kTargetWindows,
	kTargetLinux,
	kTargetMacOS,
	kTargetAndroid,
	kTargetIphone,
	kTargetIpad,
	kTargetBlackBerry,
	kTargetNaCl,
	kTargetEmscripten,
	kTargetTizen,
	kTargetWinRT,
	kTargetWP8
};
typedef enum {
	AFC_CLIP_IMAGE,
	AFC_CLIP_ELLIPSE,
	AFC_CLIP_LINE,
	AFC_CLIP_RECT,
	AFC_CLIP_ROUNDRECT,
	AFC_CLIP_COLLISION_RECT,
	AFC_CLIP_POINT,
	AFC_CLIP_TRIANGLE
} CCAFCClipType;
enum MovementEventType {
	START,
	COMPLETE,
	LOOP_COMPLETE
};
typedef enum {
	LINEAR_GRAVITY_NONE,
	LINEAR_GRAVITY_LEFT,
	LINEAR_GRAVITY_TOP,
	LINEAR_GRAVITY_RIGHT,
	LINEAR_GRAVITY_BOTTOM,
	LINEAR_GRAVITY_CENTER_VERTICAL,
	LINEAR_GRAVITY_CENTER_HORIZONTAL
} LinearGravity;
enum AnimationType {
	SINGLE_FRAME,
	ANIMATION_NO_LOOP,
	ANIMATION_TO_LOOP_FRONT,
	ANIMATION_TO_LOOP_BACK,
	ANIMATION_LOOP_FRONT,
	ANIMATION_LOOP_BACK,
	ANIMATION_MAX
};
typedef enum {
	kCCVerticalTextAlignmentTop,
	kCCVerticalTextAlignmentCenter,
	kCCVerticalTextAlignmentBottom
} CCVerticalTextAlignment;
enum SCROLLVIEW_DIR {
	SCROLLVIEW_DIR_NONE,
	SCROLLVIEW_DIR_VERTICAL,
	SCROLLVIEW_DIR_HORIZONTAL,
	SCROLLVIEW_DIR_BOTH
};
typedef enum {
	LAYOUT_COLOR_NONE,
	LAYOUT_COLOR_SOLID,
	LAYOUT_COLOR_GRADIENT
} LayoutBackGroundColorType;
typedef enum {
	LAYOUT_ABSOLUTE,
	LAYOUT_LINEAR_VERTICAL,
	LAYOUT_LINEAR_HORIZONTAL,
	LAYOUT_RELATIVE
} LayoutType;
typedef enum {
	POSITION_ABSOLUTE,
	POSITION_PERCENT
} PositionType;
typedef enum {
	kCCTexture2DPixelFormat_RGBA8888,
	kCCTexture2DPixelFormat_RGB888,
	kCCTexture2DPixelFormat_RGB565,
	kCCTexture2DPixelFormat_A8,
	kCCTexture2DPixelFormat_I8,
	kCCTexture2DPixelFormat_AI88,
	kCCTexture2DPixelFormat_RGBA4444,
	kCCTexture2DPixelFormat_RGB5A1,
	kCCTexture2DPixelFormat_PVRTC4,
	kCCTexture2DPixelFormat_PVRTC2,
	kCCTexture2DPixelFormat_Default,
	kTexture2DPixelFormat_RGBA8888,
	kTexture2DPixelFormat_RGB888,
	kTexture2DPixelFormat_RGB565,
	kTexture2DPixelFormat_A8,
	kTexture2DPixelFormat_RGBA4444,
	kTexture2DPixelFormat_RGB5A1,
	kTexture2DPixelFormat_Default
} CCTexture2DPixelFormat;
typedef enum {
	SIZE_ABSOLUTE,
	SIZE_PERCENT
} SizeType;
typedef enum {
	kCCControlStepperPartMinus,
	kCCControlStepperPartPlus,
	kCCControlStepperPartNone
} CCControlStepperPart;
typedef enum {
	SPX_DELAY,
	SPX_NODELAY
} CCSPX3ActionMode;
typedef enum {
	LAYOUT_PARAMETER_NONE,
	LAYOUT_PARAMETER_LINEAR,
	LAYOUT_PARAMETER_RELATIVE
} LayoutParameterType;
typedef enum {
	LoadingBarTypeLeft,
	LoadingBarTypeRight
} LoadingBarType;
typedef enum {
	kCCDirectorProjection2D,
	kCCDirectorProjection3D,
	kCCDirectorProjectionCustom,
	kCCDirectorProjectionDefault
} ccDirectorProjection;
typedef enum {
	kCCPositionTypeFree,
	kCCPositionTypeRelative,
	kCCPositionTypeGrouped
} tCCPositionType;
enum DisplayType {
	CS_DISPLAY_SPRITE,
	CS_DISPLAY_ARMATURE,
	CS_DISPLAY_PARTICLE,
	CS_DISPLAY_MAX
};
enum EditBoxInputFlag {
	kEditBoxInputFlagPassword,
	kEditBoxInputFlagSensitive,
	kEditBoxInputFlagInitialCapsWord,
	kEditBoxInputFlagInitialCapsSentence,
	kEditBoxInputFlagInitialCapsAllCharacters
};
typedef enum {
	kCCTMXOrientationOrthogonal,
	kCCTMXOrientationIsometric,
	kCCTMXOrientationHexagonal
} cbTMXOrientation;
typedef enum {
	kLanguageEnglish,
	kLanguageChinese,
	kLanguageFrench,
	kLanguageItalian,
	kLanguageGerman,
	kLanguageSpanish,
	kLanguageDutch,
	kLanguageRussian,
	kLanguageKorean,
	kLanguageJapanese,
	kLanguageHungarian,
	kLanguagePortuguese,
	kLanguageArabic
} ccLanguageType;
typedef enum {
	kCCTouchesAllAtOnce,
	kCCTouchesOneByOne
} ccTouchesMode;
typedef enum {
	kFmtJpg,
	kFmtPng,
	kFmtTiff,
	kFmtWebp,
	kFmtRawData,
	kFmtUnKnown
} EImageFormat;
typedef enum {
	SPX_TILE_INDEX,
	SPX_TILE_CLIP
} CCSPX3TileSetMode;
typedef enum {
	LAYOUT_CLIPPING_STENCIL,
	LAYOUT_CLIPPING_SCISSOR
} LayoutClippingType;
typedef enum {
	kCCTextAlignmentLeft,
	kCCTextAlignmentCenter,
	kCCTextAlignmentRight
} CCTextAlignment;
typedef enum {
	kCCTransitionOrientationLeftOver,
	kCCTransitionOrientationRightOver,
	kCCTransitionOrientationUpOver,
	kCCTransitionOrientationDownOver
} tOrientation;
typedef enum {
	UI_TEX_TYPE_LOCAL,
	UI_TEX_TYPE_PLIST
} TextureResType;
typedef enum {
	RELATIVE_ALIGN_NONE,
	RELATIVE_ALIGN_PARENT_TOP_LEFT,
	RELATIVE_ALIGN_PARENT_TOP_CENTER_HORIZONTAL,
	RELATIVE_ALIGN_PARENT_TOP_RIGHT,
	RELATIVE_ALIGN_PARENT_LEFT_CENTER_VERTICAL,
	RELATIVE_CENTER_IN_PARENT,
	RELATIVE_ALIGN_PARENT_RIGHT_CENTER_VERTICAL,
	RELATIVE_ALIGN_PARENT_LEFT_BOTTOM,
	RELATIVE_ALIGN_PARENT_BOTTOM_CENTER_HORIZONTAL,
	RELATIVE_ALIGN_PARENT_RIGHT_BOTTOM,
	RELATIVE_LOCATION_ABOVE_LEFTALIGN,
	RELATIVE_LOCATION_ABOVE_CENTER,
	RELATIVE_LOCATION_ABOVE_RIGHTALIGN,
	RELATIVE_LOCATION_LEFT_OF_TOPALIGN,
	RELATIVE_LOCATION_LEFT_OF_CENTER,
	RELATIVE_LOCATION_LEFT_OF_BOTTOMALIGN,
	RELATIVE_LOCATION_RIGHT_OF_TOPALIGN,
	RELATIVE_LOCATION_RIGHT_OF_CENTER,
	RELATIVE_LOCATION_RIGHT_OF_BOTTOMALIGN,
	RELATIVE_LOCATION_BELOW_LEFTALIGN,
	RELATIVE_LOCATION_BELOW_CENTER,
	RELATIVE_LOCATION_BELOW_RIGHTALIGN
} RelativeAlign;
typedef enum {
	CC_GL_ALL
} ccGLServerState;
typedef enum {
	WidgetTypeWidget,
	WidgetTypeContainer
} WidgetType;
typedef enum {
	SPX_TRANS_NONE,
	SPX_TRANS_MIRROR_ROT180,
	SPX_TRANS_MIRROR,
	SPX_TRANS_ROT180,
	SPX_TRANS_MIRROR_ROT270,
	SPX_TRANS_ROT90,
	SPX_TRANS_ROT270,
	SPX_TRANS_MIRROR_ROT90
} CCSPXTransform;
typedef enum {
	BRIGHT_NONE,
	BRIGHT_NORMAL,
	BRIGHT_HIGHLIGHT
} BrightStyle;
typedef enum {
	kCCProgressTimerTypeRadial,
	kCCProgressTimerTypeBar
} CCProgressTimerType;
struct CCAFCClipMappingRule {
	CCAFCClipMappingRuleType type;
	int sourceClipIndex;
};
struct CCSPXCollision {
	int x;
	int y;
	int width;
	int height;
};
typedef struct {
	unsigned int num;
	unsigned int max;
} ccArray;
struct CCSPX3Tile {
	short x1;
	short y1;
	short x2;
	short y2;
	short right();
	short bottom();
	short top();
	short height();
	short width();
	short left();
};
struct CCSPXFrameTile {
	int index;
	int x;
	int y;
	CCSPXTransform transform;
};
struct UT_hash_handle {
	unsigned int keylen;
	unsigned int hashv;
};
typedef struct {
	unsigned char r;
	unsigned char g;
	unsigned char b;
	unsigned char a;
} ccColor4B;
struct CCAFCClipData {
	ccPoint clipPos;
};
typedef struct {
	float r;
	float g;
	float b;
	float a;
} ccColor4F;
struct CCSPXReferencePoint {
	int x;
	int y;
};
struct CCAuroraAnimation {
	short frameCount;
	short firstFrameIndex;
};
typedef struct {
	int left;
	int top;
	int right;
	int bottom;
} ccBMFontPadding;
struct ccPoint {
	float x;
	float y;
};
struct CCAuroraModule {
	CCAuroraModuleType type;
	int imageIndex;
	int color;
	short x;
	short y;
	short w;
	short h;
};
struct CCAffineTransform {
	float a;
	float b;
	float c;
	float d;
	float tx;
	float ty;
};
typedef struct {
	ccVertex3F bl;
	ccVertex3F br;
	ccVertex3F tl;
	ccVertex3F tr;
} ccQuad3;
typedef struct {
	int status;
	unsigned char type;
	unsigned char pixelDepth;
	short width;
	short height;
	int flipped;
} tImageTGA;
struct ccAABB {
	CCPoint min;
	CCPoint max;
};
struct CCArcticFrame {
	short moduleCount;
	short firstModuleIndex;
	short collisionRectCount;
};
typedef struct {
	double r;
	double g;
	double b;
	double a;
} RGBA;
typedef struct {
	unsigned int key;
	ccBMFontDef fontDef;
	UT_hash_handle hh;
} tCCFontDefHashElement;
struct kmMat4 {
};
struct sockaddr_in {
	unsigned short sin_family;
	unsigned short sin_port;
	in_addr sin_addr;
};
struct CCArcticAnimation {
	short frameCount;
	short firstFrameIndex;
};
struct CCSPXTile {
	short x;
	short y;
	short w;
	short h;
};
struct ccPosition {
	int x;
	int y;
};
typedef struct {
	unsigned char r;
	unsigned char g;
	unsigned char b;
} ccColor3B;
struct CCAuroraFrame {
	short moduleCount;
	short firstModuleIndex;
	short collisionRectCount;
	ccRect bound;
};
struct ccInsets {
	float top;
	float left;
	float right;
	float bottom;
};
struct CCArcticAnimationFrame {
	short index;
	short delay;
	short offsetX;
	short offsetY;
	unsigned char flags;
};
typedef struct {
	ccV3F_C4B_T2F tl;
	ccV3F_C4B_T2F bl;
	ccV3F_C4B_T2F tr;
	ccV3F_C4B_T2F br;
} ccV3F_C4B_T2F_Quad;
struct CCAuroraAnimationFrame {
	short index;
	short delay;
	short offsetX;
	short offsetY;
	unsigned char flags;
};
typedef struct {
	float x;
	float y;
	float z;
} ccVertex3F;
struct CCSPX3Patch {
	CCSPX3PatchType type;
};
typedef struct {
	unsigned int src;
	unsigned int dst;
} ccBlendFunc;
typedef struct {
	CCRect begin;
	CCRect end;
	float duration;
} CCIMEKeyboardNotificationInfo;
struct ccRect {
	float x;
	float y;
	float width;
	float height;
};
struct CCSPXActionFrame {
	int index;
	float duration;
};
struct CCArcticModule {
	int imageIndex;
	short x;
	short y;
	short w;
	short h;
};
struct CCAuroraFrameModule {
	short index;
	short x;
	short y;
	short palette;
	unsigned char flags;
};
typedef struct {
	CCPoint endPosition;
	CCPoint controlPoint_1;
	CCPoint controlPoint_2;
} ccBezierConfig;
typedef struct {
	unsigned int minFilter;
	unsigned int magFilter;
	unsigned int wrapS;
	unsigned int wrapT;
} ccTexParams;
typedef struct {
	int key;
	int amount;
	UT_hash_handle hh;
} tCCKerningHashElement;
typedef struct {
	double h;
	double s;
	double v;
} HSV;
struct ccColorHSV {
	float h;
	float s;
	float v;
};
struct CCArcticFrameModule {
	short index;
	short x;
	short y;
	unsigned char flags;
};
